<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>处于量子叠加态的TCP端口 · 余思于斯 - Fism</title><meta name="description" content="注：本文翻译自Cloudflare博客The quantum state of a TCP port，同时融合了一些我个人的理解。
有时候我们可以有这样的感觉，一个看似简单的问题却可以引申出很复杂的答案，今天就让我们来看一个Linux网络协议栈中的例子。
什么时候两个TCP Socket可以共享一个"><meta name="og:description" content="注：本文翻译自Cloudflare博客The quantum state of a TCP port，同时融合了一些我个人的理解。
有时候我们可以有这样的感觉，一个看似简单的问题却可以引申出很复杂的答案，今天就让我们来看一个Linux网络协议栈中的例子。
什么时候两个TCP Socket可以共享一个"><meta name="twitter:site" content="余思于斯 - Fism"><meta name="twitter:title" content="处于量子叠加态的TCP端口"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">Fism</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">余思于斯</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/about.html">About</a></li><li class="soc"></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2024&nbsp;<a target="_blank" href="https://fishjump.github.io" rel="noopener noreferrer">Yue Yu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>处于量子叠加态的TCP端口</a></p><p class="post-meta"></p><p class="post-abstract"><p>注：本文翻译自Cloudflare博客The quantum state of a TCP port，同时融合了一些我个人的理解。</p>
<p>有时候我们可以有这样的感觉，一个看似简单的问题却可以引申出很复杂的答案，今天就让我们来看一个Linux网络协议栈中的例子。</p>
<h2 id="什么时候两个TCP-Socket可以共享一个地址？"><a href="#什么时候两个TCP-Socket可以共享一个地址？" class="headerlink" title="什么时候两个TCP Socket可以共享一个地址？"></a>什么时候两个TCP Socket可以共享一个地址？</h2><p>如果我在浏览器上输入blog.cloudflare.com，浏览器会尝试使用TCP连接到一个远程的IP地址，就比方它是104.16.132.229:443吧。同时，我们本地的Linux操作系统也会随机分配一个端口给我们的本地IP地址，比如说是192.0.2.42:54321吧。如果这时候我想要访问另外一个网站会发生什么？我们可以利用这同一个端口号和本地IP建立一个新的TCP连接吗？</p>
<p>这里博主（原作者）准备了八个小问题，让我们通过启发式学习的方法来学习Linux TCP Socket的地址和端口复用规则。最后的我们的到的结论可能有些反常识。</p>
<p>我们的问题主要分为以下两种场景：</p>
<p><img src="/images/the-quantum-state-of-a-tcp-port-01.png"></p>
<p>第一种情况，两个绑定到不同本地IP（例如我们有双网卡，或者有虚拟网卡）但是相同端口的socket去访问同一个远程地址，并且远程地址的端口号也相同。第二种情况，我们使用一个本地的IP去访问两个不同IP不同端口的远程地址。</p>
<p>在我们的小问题中，我们会：</p>
<ol>
<li>让OS自动分配socket的IP地址和（或）端口号，又或者</li>
<li>我们会显式地在connect之前，使用bind指定本地地址和端口。这样的作法有个术语叫做bind-before-connect</li>
</ol>
<p>因为我们在测试bind()的一些边界情况，所以我们需要限定系统可以用的本地地址资源，也就是（IP，port）这样的二元组。我们当然可以先起很多个socket去把资源耗尽，但是有一种更简便的方法，可以参考参考资料中的【Linux网络相关系统配置】。这样做的话，我们可以保证系统只有一个可用的临时本地端口，端口号是60000。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.ip_local_port_range=<span class="string">&#x27;60000 60000&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在开始尝试看Python代码回答下面的小问题，预测代码的结果，它的输出是什么，结果是成功还是失败，如果是失败为什么？不要去尝试问ChatGPT，不然问题就没有意义了。问题的答案可以在文章最后查看。</p>
<p>当然，一份代码总是有一些初始化步骤，这里我直接放出来这个初始化步骤，在接下来的小问题中我们会省略这些初始化步骤，让我们关心问题的核心。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> system</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># Missing constants</span></span><br><span class="line">IP_BIND_ADDRESS_NO_PORT = <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Our network namespace has just *one* ephemeral port</span></span><br><span class="line">system(<span class="string">&quot;sysctl -w net.ipv4.ip_local_port_range=&#x27;60000 60000&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Open a listening socket at *:1234. We will connect to it.</span></span><br><span class="line">ln = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">ln.bind((<span class="string">&quot;&quot;</span>, <span class="number">1234</span>))</span><br><span class="line">ln.listen(SOMAXCONN)</span><br></pre></td></tr></table></figure>

<h2 id="场景一：如果IP不同，但是端口相同的情况"><a href="#场景一：如果IP不同，但是端口相同的情况" class="headerlink" title="场景一：如果IP不同，但是端口相同的情况"></a>场景一：如果IP不同，但是端口相同的情况</h2><p>在场景一中，我们连接到相同的远端地址，127.9.9.9:1234。Sockets会使用不同的本地IP，我们是否能够共享端口，或者端口是否足够？</p>
<table>
<thead>
<tr>
<th>local IP</th>
<th>local port</th>
<th>remote IP</th>
<th>remote port</th>
</tr>
</thead>
<tbody><tr>
<td>unique</td>
<td>same</td>
<td>same</td>
<td>same</td>
</tr>
<tr>
<td>127.0.0.1 <br/> 127.1.1.1 <br/> 127.2.2.2</td>
<td>60000</td>
<td>127.9.9.9</td>
<td>1234</td>
</tr>
</tbody></table>
<h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>在本地，我们将两个socket明确绑定到两个IP，而端口由系统指定。请记住此时我们本地可用的临时端口只有60000号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s1.bind((<span class="string">&#x27;127.1.1.1&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">s1.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">s1.getsockname(), s1.getpeername()</span><br><span class="line"></span><br><span class="line">s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s2.bind((<span class="string">&#x27;127.2.2.2&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">s2.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">s2.getsockname(), s2.getpeername()</span><br></pre></td></tr></table></figure>

<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>这次设置几乎与之前相同。但是我们让操作系统来决定第一个socket的IP地址和端口号。你认为这次的结果会与上一个问题有所不同吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s1.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">s1.getsockname(), s1.getpeername()</span><br><span class="line"></span><br><span class="line">s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s2.bind((<span class="string">&#x27;127.2.2.2&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">s2.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">s2.getsockname(), s2.getpeername()</span><br></pre></td></tr></table></figure>

<h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>这个问题与上面的问题很相似，我们只是改变了顺序。首先，我们明确指定第一个socket的IP地址和端口。然后我们让操作系统来决定第二个socket的IP地址和端口号。显然，这样的顺序变化不应该有任何区别，对吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s1.bind((<span class="string">&#x27;127.1.1.1&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">s1.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">s1.getsockname(), s1.getpeername()</span><br><span class="line"></span><br><span class="line">s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s2.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">s2.getsockname(), s2.getpeername()</span><br></pre></td></tr></table></figure>

<h2 id="场景二：当本地IP和端口相同，但是远端IP不同的时候"><a href="#场景二：当本地IP和端口相同，但是远端IP不同的时候" class="headerlink" title="场景二：当本地IP和端口相同，但是远端IP不同的时候"></a>场景二：当本地IP和端口相同，但是远端IP不同的时候</h2><p>在场景二中，我们调转一下情况。不再是多个本地IP和一个远程地址，而是一个本地地址127.0.0.1:60000和两个不同的远程地址。问题不变，两个socket能共享本地端口吗？提醒：临时端口范围仍然只有一个，60000号端口。</p>
<table>
<thead>
<tr>
<th>local IP</th>
<th>local port</th>
<th>remote IP</th>
<th>remote port</th>
</tr>
</thead>
<tbody><tr>
<td>unique</td>
<td>same</td>
<td>same</td>
<td>same</td>
</tr>
<tr>
<td>127.0.0.1</td>
<td>60000</td>
<td>127.8.8.8 <br/> 127.9.9.9</td>
<td>1234</td>
</tr>
</tbody></table>
<h3 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h3><p>让我们从一个基础的热身问题开始吧。我们使用connect()去连接两个不同的远端地址。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s1.connect((<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">s1.getsockname(), s1.getpeername()</span><br><span class="line"></span><br><span class="line">s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s2.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">s2.getsockname(), s2.getpeername()</span><br></pre></td></tr></table></figure>

<h3 id="问题五"><a href="#问题五" class="headerlink" title="问题五"></a>问题五</h3><p>如果我们使用bind()去显式绑定本地IP地址，但是让操作系统去选择端口。这样的话结果有什么变化吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s1.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">s1.connect((<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">s1.getsockname(), s1.getpeername()</span><br><span class="line"></span><br><span class="line">s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s2.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">s2.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">s2.getsockname(), s2.getpeername()</span><br></pre></td></tr></table></figure>

<h3 id="问题六"><a href="#问题六" class="headerlink" title="问题六"></a>问题六</h3><p>这次我们显式的指定本地IP地址和端口，在现实开发过程中，有时候我们确实需要这样去指定本地端口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s1.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60_000</span>))</span><br><span class="line">s1.connect((<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">s1.getsockname(), s1.getpeername()</span><br><span class="line"></span><br><span class="line">s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s2.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60_000</span>))</span><br><span class="line">s2.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">s2.getsockname(), s2.getpeername()</span><br></pre></td></tr></table></figure>

<h3 id="问题七"><a href="#问题七" class="headerlink" title="问题七"></a>问题七</h3><p>让我们来让问题变得更复杂一点，我们加入了SO_REUSEADDR flag。</p>
<p>首先，我们告诉操作系统帮我们选择一个本地IP地址和端口，然后我们显式bind到相同的IP地址和端口（我们知道OS一定会分配给我们60000端口）。第二个socket同样使用了本地地址重用，这种情况是被允许的吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s1.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">s1.connect((<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">s1.getsockname(), s1.getpeername()</span><br><span class="line"></span><br><span class="line">s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s2.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">s2.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60_000</span>))</span><br><span class="line">s2.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">s2.getsockname(), s2.getpeername()</span><br></pre></td></tr></table></figure>

<h3 id="问题八"><a href="#问题八" class="headerlink" title="问题八"></a>问题八</h3><p>最后一个问题，让我们来调转一下问题七中的顺序。按照常理来说结果应该是一样的，这对吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s1.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">s1.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60_000</span>))</span><br><span class="line">s1.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">s1.getsockname(), s1.getpeername()</span><br><span class="line"></span><br><span class="line">s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">s2.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">s2.connect((<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">s2.getsockname(), s2.getpeername()</span><br></pre></td></tr></table></figure>

<h2 id="问题答案"><a href="#问题答案" class="headerlink" title="问题答案"></a>问题答案</h2><h3 id="场景一-问题一"><a href="#场景一-问题一" class="headerlink" title="场景一 - 问题一"></a>场景一 - 问题一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.bind((<span class="string">&#x27;127.1.1.1&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.getsockname(), s1.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.1.1.1&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.bind((<span class="string">&#x27;127.2.2.2&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.getsockname(), s2.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.2.2.2&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br></pre></td></tr></table></figure>

<p>代码成功运行，共享本地端口。</p>
<h3 id="场景一-问题二"><a href="#场景一-问题二" class="headerlink" title="场景一 - 问题二"></a>场景一 - 问题二</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.getsockname(), s1.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.bind((<span class="string">&#x27;127.2.2.2&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.getsockname(), s2.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.2.2.2&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br></pre></td></tr></table></figure>

<p>代码成功运行，共享本地端口。</p>
<h3 id="场景一-问题三"><a href="#场景一-问题三" class="headerlink" title="场景一 - 问题三"></a>场景一 - 问题三</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.bind((<span class="string">&#x27;127.1.1.1&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.getsockname(), s1.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.1.1.1&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">OSError: [Errno <span class="number">99</span>] Cannot assign requested address</span><br></pre></td></tr></table></figure>

<p>代码运行失败，无法共享端口。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用<code>IP_BIND_ADDRESS_NO_PORT</code>选项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.setsockopt(SOL_IP, IP_BIND_ADDRESS_NO_PORT, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.bind((<span class="string">&#x27;127.1.1.1&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.getsockname(), s1.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.1.1.1&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.getsockname(), s2.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br></pre></td></tr></table></figure>

<h3 id="场景二-问题四"><a href="#场景二-问题四" class="headerlink" title="场景二 - 问题四"></a>场景二 - 问题四</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.connect((<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.getsockname(), s1.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.getsockname(), s2.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br></pre></td></tr></table></figure>

<p>代码成功运行，共享本地端口。</p>
<h3 id="场景二-问题五"><a href="#场景二-问题五" class="headerlink" title="场景二 - 问题五"></a>场景二 - 问题五</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.connect((<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.getsockname(), s1.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">OSError: [Errno <span class="number">98</span>] Address already <span class="keyword">in</span> use</span><br></pre></td></tr></table></figure>

<p>代码运行失败，无法共享端口。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用<code>IP_BIND_ADDRESS_NO_PORT</code>选项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.setsockopt(SOL_IP, IP_BIND_ADDRESS_NO_PORT, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.connect((<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.getsockname(), s1.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.setsockopt(SOL_IP, IP_BIND_ADDRESS_NO_PORT, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.getsockname(), s2.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br></pre></td></tr></table></figure>

<h3 id="场景二-问题六"><a href="#场景二-问题六" class="headerlink" title="场景二 - 问题六"></a>场景二 - 问题六</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60_000</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.connect((<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.getsockname(), s1.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60_000</span>))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">OSError: [Errno <span class="number">98</span>] Address already <span class="keyword">in</span> use</span><br></pre></td></tr></table></figure>

<p>代码运行失败，无法共享端口。</p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用<code>SO_REUSEADDR</code>选项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60_000</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.connect((<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.getsockname(), s1.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60_000</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.getsockname(), s2.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br></pre></td></tr></table></figure>

<h3 id="场景二-问题七"><a href="#场景二-问题七" class="headerlink" title="场景二 - 问题七"></a>场景二 - 问题七</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.connect((<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.getsockname(), s1.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60_000</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.getsockname(), s2.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br></pre></td></tr></table></figure>

<p>代码成功运行，共享本地端口。</p>
<h3 id="场景二-问题八"><a href="#场景二-问题八" class="headerlink" title="场景二 - 问题八"></a>场景二 - 问题八</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60_000</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.connect((<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.getsockname(), s1.getpeername()</span><br><span class="line">((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">60000</span>), (<span class="string">&#x27;127.9.9.9&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.connect((<span class="string">&#x27;127.8.8.8&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">OSError: [Errno <span class="number">99</span>] Cannot assign requested address</span><br></pre></td></tr></table></figure>

<p>代码运行失败，无法共享端口，没有解决方案。</p>
<h2 id="本地TCP端口的三重秘密"><a href="#本地TCP端口的三重秘密" class="headerlink" title="本地TCP端口的三重秘密"></a>本地TCP端口的三重秘密</h2><p>现在我们真的弄明白了Linux端口分配的机制吗？也许并没有。我们只是在做类似于对一个黑箱做逆向工程。在这个黑箱背后藏着什么呢？我们来看看。</p>
<p>Linux会在一个叫做bhash的哈希表中记录跟踪所有被使用的TCP<strong>端口</strong>。这里不要和ehah哈希表搞混了，ehash表用于记录已经建立连接的(local socket，remote socket)对。</p>
<p><img src="/images/the-quantum-state-of-a-tcp-port-02.png"></p>
<p>每个哈希表的入口指向一个叫做bind bucket的链表。bind bucket将所有共享端口的socket放在一起。具体来说，做哈希的内容是：</p>
<ol>
<li>socket的network namespace</li>
<li>socket的VRF设备（Virtual Routing and Forwarding）</li>
<li>socket绑定的本地端口</li>
</ol>
<p>现在让我们来考虑最简单的情况，只有一个网络命名空间，没有VRF。这样的情况下，我们可以说socket所在的bind bucket只和本地端口有关。也就是说，在每个bind bucket中的socket通过一个链表来共享一个本地端口。</p>
<p>当我们让内核去给一个socket分配一个本地地址时，它会去检查现有的socket，因为只有满足特定条件我们才可以进行本地端口共享。下面这段注释从include&#x2F;net&#x2F;inet_hashtables.h中复制。</p>
<ol>
<li>绑定到不同interface（网络接口，对于PC可以简单当作网卡）可以共享本地端口。否则，检测情况2</li>
<li>如果所有的socket都有sk-&gt;sk_reuse标志，而且其中没有socket在TCP_LISTEN状态，那么可以共享本地端口.否则，检测情况3</li>
<li>如果所有socket都绑定到了不同的地址，那么端口可以共享。如果也不满足这个条件，那么端口不能共享。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are a few simple rules, which allow for local port reuse by</span></span><br><span class="line"><span class="comment"> * an application.  In essence:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   1) Sockets bound to different interfaces may share a local port.</span></span><br><span class="line"><span class="comment"> *      Failing that, goto test 2.</span></span><br><span class="line"><span class="comment"> *   2) If all sockets have sk-&gt;sk_reuse set, and none of them are in</span></span><br><span class="line"><span class="comment"> *      TCP_LISTEN state, the port may be shared.</span></span><br><span class="line"><span class="comment"> *      Failing that, goto test 3.</span></span><br><span class="line"><span class="comment"> *   3) If all sockets are bound to a specific inet_sk(sk)-&gt;rcv_saddr local</span></span><br><span class="line"><span class="comment"> *      address, and none of them are the same, the port may be</span></span><br><span class="line"><span class="comment"> *      shared.</span></span><br><span class="line"><span class="comment"> *      Failing this, the port cannot be shared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The interesting point, is test #2.  This is what an FTP server does</span></span><br><span class="line"><span class="comment"> * all day.  To optimize this case we use a specific flag bit defined</span></span><br><span class="line"><span class="comment"> * below.  As we add sockets to a bind bucket list, we perform a</span></span><br><span class="line"><span class="comment"> * check of: (newsk-&gt;sk_reuse &amp;&amp; (newsk-&gt;sk_state != TCP_LISTEN))</span></span><br><span class="line"><span class="comment"> * As long as all sockets added to a bind bucket pass this test,</span></span><br><span class="line"><span class="comment"> * the flag bit will be set.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>上面的注释表明内核试图去尽可能保证端口没有冲突。为此，bind bucket内有一些额外的属性来汇总它所持有的sockets的属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_bucket</span> &#123;</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">        <span class="type">signed</span> <span class="type">char</span>          fastreuse;</span><br><span class="line">        <span class="type">signed</span> <span class="type">char</span>          fastreuseport;</span><br><span class="line">        <span class="type">kuid_t</span>               fastuid;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_IPV6)</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span>      <span class="title">fast_v6_rcv_saddr</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        __be32               fast_rcv_saddr;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span>       fast_sk_family;</span><br><span class="line">        <span class="type">bool</span>                 fast_ipv6_only;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>让我们重点关注第一个flag，fastreuse。它从Linux 2.1.90版本开始存在。最开始它是以一个bit flag的形式存在，随着时间的发展，它变成了一个字节大小的字段。而其他的六个字段和SO_REUSEPORT这个flag有关，从Linux 3.9加入内核，在今天不会涉及到。</p>
<p>当内核需要将一个socket绑定到一个端口的时候，它首先会去在bind bucket中寻找这个端口。而让问题更复杂的是，在内核中寻找TCP bind bucket的逻辑被分散在两处。它有可能发生在bind()系统调用中，也可能发生在connect()系统调用中。具体使用哪一块的逻辑取决于socket的初始化方式。</p>
<p><img src="/images/the-quantum-state-of-a-tcp-port-03.png"></p>
<p>但是不论怎样，当我们在执行inet_csk_get_port()或__inet_hash_connect()的时候，我们总是去遍历bhash中对应位置的bind bucket链表去寻找一个匹配的端口号。端口号或许已经在bucket中存在；又或许不存在，我们需要创建一个新的bucket元素。当它存在时，fastreuse可能有三种状态，-1，0，或者1。也许内核开发者收到了量子力学的启发？</p>
<p>三种状态其实反映了bind bucket的两个方面：</p>
<ol>
<li>哪些socket在bind bucket中</li>
<li>什么时候可以共享端口</li>
</ol>
<p>让我们尝试解密三种fastreuse的状态以及在每种情况下的含义。首先，fastreuse字段对bind bucket的拥有者（即哪些使用这个端口的socket）传递了什么信息？</p>
<table>
<thead>
<tr>
<th>fastreuse</th>
<th>使用这个端口的多个（或者只有一个）socket中有</th>
</tr>
</thead>
<tbody><tr>
<td>-1</td>
<td>一个或者多个socket是通过connect()获得得一个临时端口号</td>
</tr>
<tr>
<td>0</td>
<td>一个或则多个socket调用bind()时没有设置SO_REUSEADDR</td>
</tr>
<tr>
<td>+1</td>
<td>一个或则多个socket调用bind()时设置了SO_REUSEADDR</td>
</tr>
</tbody></table>
<p>尽管上面的说明不是全部的真相，但是目前来说它足够“正确”了。我们马上会接触到更详细的内容。</p>
<p>当我们需要端口共享时，事实可能远比我们想象中更不直观，符合直觉。</p>
<table>
<thead>
<tr>
<th>我能否 … 当 … 时</th>
<th>fastreuse &#x3D; -1</th>
<th>fastreuse &#x3D; 0</th>
<th>fastreuse &#x3D; +1</th>
</tr>
</thead>
<tbody><tr>
<td>调用bind()去绑定（使用临时端口或者显式指定的端口）一个相同的已经有的端口</td>
<td>当且仅当IP不同时，可以 ①</td>
<td>← 同上</td>
<td>← 同上</td>
</tr>
<tr>
<td>调用bind()去绑定一个端口，并且设置SO_REUSEADDR</td>
<td>当且仅当IP不同时，<strong>或者</strong>发生冲突的其他所有socket也设置了SO_REUSEADDR ①</td>
<td>← 同上</td>
<td>可以 ②</td>
</tr>
<tr>
<td>调用connect()，使用相同的临时端口，访问相同的远端（IP，port）地址</td>
<td>当且仅当本地IP不同时，可以③</td>
<td>不可以 ③</td>
<td>不可以 ③</td>
</tr>
<tr>
<td>调用connect()，使用相同的临时端口，访问不同的远端（IP，port）地址</td>
<td>可以 ③</td>
<td>不可以 ③</td>
<td>不可以 ③</td>
</tr>
</tbody></table>
<p>① 当显式绑定时取决于由inet_csk_get_port()调用的inet_csk_bind_conflict()，<strong>或者</strong>使用connect隐式绑定时，取决于由inet_csk_get_port()调用的inet_csk_find_open_port()。</p>
<p>② 对于fastreuse &#x3D;&#x3D; 1的bind bucket，inet_csk_get_port()跳过端口冲突检查。</p>
<p>③ 这个调用链inet_hash_connect() → __inet_hash_connect()会直接不去fastreuse !&#x3D; -1的bind bucket中找端口。</p>
<p>虽然乍一看这些规则十分复杂，但是我们可以提前出几个简单的规则：</p>
<ul>
<li>如果本地IP地址与任何现有socket没有冲突，bind()总是成功的；</li>
<li>如果bind bucket不是fastreuse &#x3D; -1，那么使用connect来分配地址总是失败的（是fastreuse &#x3D; -1也不一定成功）</li>
<li>如果没有本地和远端地址冲突，那么connect分配地址总是成功的</li>
<li>如果所有冲突的socket都设置了SO_REUSEADDR，并且没有socket在listening状态（即没有当作服务器），那么设置了SO_REUSEADDR的socket可以进行本地地址共享。</li>
</ul>
<h2 id="你听我扯这么多，但是我不信怎么办？"><a href="#你听我扯这么多，但是我不信怎么办？" class="headerlink" title="你听我扯这么多，但是我不信怎么办？"></a>你听我扯这么多，但是我不信怎么办？</h2><p>我们生在一个好时代，你不必相信我，可以使用drgn，一个内核调试工具（链接在参考资料中），去自己看看bind bucket的状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env drgn</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">dump_bhash.py - List all TCP bind buckets in the current netns.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Script is not aware of VRF.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> drgn.helpers.linux.<span class="built_in">list</span> <span class="keyword">import</span> hlist_for_each, hlist_for_each_entry</span><br><span class="line"><span class="keyword">from</span> drgn.helpers.linux.net <span class="keyword">import</span> get_net_ns_by_fd</span><br><span class="line"><span class="keyword">from</span> drgn.helpers.linux.pid <span class="keyword">import</span> find_task</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_bind_bucket</span>(<span class="params">head, net</span>):</span><br><span class="line">    <span class="keyword">for</span> tb <span class="keyword">in</span> hlist_for_each_entry(<span class="string">&quot;struct inet_bind_bucket&quot;</span>, head, <span class="string">&quot;node&quot;</span>):</span><br><span class="line">        <span class="comment"># Skip buckets not from this netns</span></span><br><span class="line">        <span class="keyword">if</span> tb.ib_net.net != net:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        port = tb.port.value_()</span><br><span class="line">        fastreuse = tb.fastreuse.value_()</span><br><span class="line">        owners_len = <span class="built_in">len</span>(<span class="built_in">list</span>(hlist_for_each(tb.owners)))</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;&#123;:8d&#125;  &#123;:&#123;sign&#125;9d&#125;  &#123;:7d&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                port,</span><br><span class="line">                fastreuse,</span><br><span class="line">                owners_len,</span><br><span class="line">                sign=<span class="string">&quot;+&quot;</span> <span class="keyword">if</span> fastreuse != <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot; &quot;</span>,</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_netns</span>():</span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    task = find_task(prog, pid)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;/proc/<span class="subst">&#123;pid&#125;</span>/ns/net&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> get_net_ns_by_fd(task, f.fileno())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;:8&#125;  &#123;:9&#125;  &#123;:7&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;TCP-PORT&quot;</span>, <span class="string">&quot;FASTREUSE&quot;</span>, <span class="string">&quot;#OWNERS&quot;</span>))</span><br><span class="line"></span><br><span class="line">    tcp_hashinfo = prog.<span class="built_in">object</span>(<span class="string">&quot;tcp_hashinfo&quot;</span>)</span><br><span class="line">    net = get_netns()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Iterate over all bhash slots</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, tcp_hashinfo.bhash_size):</span><br><span class="line">        head = tcp_hashinfo.bhash[i].chain</span><br><span class="line">        <span class="comment"># Iterate over bind buckets in the slot</span></span><br><span class="line">        dump_bind_bucket(head, net)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<p>读者可以自行验证我上面说的结论是否正确。请注意为了正确复现结果，下面的代码片段使用了和开头小问题中相同的设置。</p>
<p>两个socket共享临时端口60000：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.connect((<span class="string">&#x27;127.1.1.1&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.connect((<span class="string">&#x27;127.2.2.2&#x27;</span>, <span class="number">1234</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>!./dump_bhash.py</span><br><span class="line">TCP-PORT  FASTREUSE  <span class="comment">#OWNERS</span></span><br><span class="line">    <span class="number">1234</span>          <span class="number">0</span>        <span class="number">3</span></span><br><span class="line">   <span class="number">60000</span>         -<span class="number">1</span>        <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>两个使用了bind()的socket共享60000端口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.bind((<span class="string">&#x27;127.1.1.1&#x27;</span>, <span class="number">60_000</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.bind((<span class="string">&#x27;127.1.1.1&#x27;</span>, <span class="number">60_000</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>!./dump_bhash.py</span><br><span class="line">TCP-PORT  FASTREUSE  <span class="comment">#OWNERS</span></span><br><span class="line">    <span class="number">1234</span>          <span class="number">0</span>        <span class="number">1</span></span><br><span class="line">   <span class="number">60000</span>         +<span class="number">1</span>        <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>一个socket使用SO_REUSEADDR，一个socket不使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.bind((<span class="string">&#x27;127.1.1.1&#x27;</span>, <span class="number">60_000</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>!./dump_bhash.py</span><br><span class="line">TCP-PORT  FASTREUSE  <span class="comment">#OWNERS</span></span><br><span class="line">    <span class="number">1234</span>          <span class="number">0</span>        <span class="number">1</span></span><br><span class="line">   <span class="number">60000</span>         +<span class="number">1</span>        <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.bind((<span class="string">&#x27;127.2.2.2&#x27;</span>, <span class="number">60_000</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>!./dump_bhash.py</span><br><span class="line">TCP-PORT  FASTREUSE  <span class="comment">#OWNERS</span></span><br><span class="line">    <span class="number">1234</span>          <span class="number">0</span>        <span class="number">1</span></span><br><span class="line">   <span class="number">60000</span>          <span class="number">0</span>        <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>通过这个drgn，我们就可以写很多测试来证明我的结论是正确的。但是最后一个代码片段中发生了什么导致fastreuse从+1变成了0。这代表我们还没有完全理解fastreuse的机制。让我们来画一个状态机图吧。</p>
<h2 id="fastreuse的状态机"><a href="#fastreuse的状态机" class="headerlink" title="fastreuse的状态机"></a>fastreuse的状态机</h2><p>正如我们刚刚看到的结果，bind bucket不必在整个生命周期中始终为fastreuse &#x3D;&#x3D; 1的状态。当我们向bind bucket中添加socket的时候就可以改变其状态。例如刚刚，它从1变成了0，当：</p>
<ol>
<li>没有任何冲突</li>
<li>没有设置SO_REUSEADDR</li>
</ol>
<p><img src="/images/the-quantum-state-of-a-tcp-port-04.png"></p>
<p>我们可以通过仔细阅读inet_csk_get_port → inet_csk_update_fastreuse的源码来确定全部细节。现在，我们已经了解了内核端口复用的全部机制，但是引出了另外一个问题。</p>
<h2 id="为什么我们需要思考端口复用的细节"><a href="#为什么我们需要思考端口复用的细节" class="headerlink" title="为什么我们需要思考端口复用的细节"></a>为什么我们需要思考端口复用的细节</h2><p>首先，当你遇到bind()系统调用返回EADDRINUSE错误时，或者connect()返回EADDRNOTAVAIL错误时，你可以知道发生了什么，或者至少有工具可以找出答案。</p>
<p>其次，因为我们（Cloudflare）之前已经宣传过一种从特定范围的端口打开连接的技术（放在参考资料里面），其中涉及使用SO_REUSEADDR选项对socket进行bind()。 当时我们没有意识到，存在一种特殊情况，即其无法与常规的，使用connect()分配地址的socket共享同一端口。虽然这不会影响这项技术的价值，但是知道更多的细节总是好的。</p>
<p>为了让事情更简单，Cloudflare和Linux社区合作，添加了信了socket选项来扩展内核API。IP_LOCAL_PORT_RANGE让用户可以指定本地端口范围，在Linux 6.3中加入内核。有了这个选项，我们可以不必依赖bind的技巧，让上面的技术可以和常规的，通过connect()获取地址的socket共享本地端口。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们提出了一个相对简单的问题，两个TCP socket在什么情况下可以共享一个本地地址？并努力寻找答案。答案很复杂，无法一言以蔽之。 并且这甚至不是完整的答案。 毕竟我们忽略了SO_REUSEPORT，并且没有考虑与在TCP_LISTEN状态的socket的冲突。</p>
<p>不过，如果一定要有一个简单的结论的话，那就是对socket进行bind()操作可能会产生很复杂的后果。当使用bind()选择出口IP地址时，最好同时带上IP_BIND_ADDRESS_NO_PORT，并将使用内核默认分配的端口。否则我们可能会无意中阻止本地TCP端口复用。</p>
<p>遗憾的是，这个经验不适用于UDP，因为IP_BIND_ADDRESS_NO_PORT对UDP没有用。不过这就是另一回事了，今天不展开讲了（也许之后会写写）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Linux网络相关系统配置：<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/networking/ip-sysctl.html#ip-variables">https://www.kernel.org/doc/html/latest/networking/ip-sysctl.html?#ip-variables</a><br>内核调试工具drgn：<a target="_blank" rel="noopener" href="https://drgn.readthedocs.io/en/latest/index.html">https://drgn.readthedocs.io/en/latest/index.html</a><br>如何防止临时端口耗尽并且爱上TCP长连接： <a target="_blank" rel="noopener" href="https://blog.cloudflare.com/how-to-stop-running-out-of-ephemeral-ports-and-start-to-love-long-lived-connections/">https://blog.cloudflare.com/how-to-stop-running-out-of-ephemeral-ports-and-start-to-love-long-lived-connections/</a></p>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=https://fishjump.github.io//posts/the-quantum-state-of-a-tcp-port/%20余思于斯 - Fism%20处于量子叠加态的TCP端口"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/posts/linux-kernel-net-07/" title="从内核出发手撕Linux网络协议栈(七)"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 从内核出发手撕Linux网络协议栈(七)</a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2024&nbsp;<a target="_blank" href="https://fishjump.github.io" rel="noopener noreferrer">Yue Yu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>