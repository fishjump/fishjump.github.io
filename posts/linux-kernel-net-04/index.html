<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>从内核出发手撕Linux网络协议栈(四) · 余思于斯 - Fism</title><meta name="description" content="Bind系统调用的定义在上一集，我们讨论了socket系统调用的实现，并且介绍了一些关于阅读Linux内核代码的思路。这一集，我们将会拆解网络协议栈中的bind系统调用。我们首先可以通过man bind命令来查看一下它的函数原型。
12345#include &amp;lt;sys/types.h&amp;gt; "><meta name="og:description" content="Bind系统调用的定义在上一集，我们讨论了socket系统调用的实现，并且介绍了一些关于阅读Linux内核代码的思路。这一集，我们将会拆解网络协议栈中的bind系统调用。我们首先可以通过man bind命令来查看一下它的函数原型。
12345#include &amp;lt;sys/types.h&amp;gt; "><meta name="twitter:site" content="余思于斯 - Fism"><meta name="twitter:title" content="从内核出发手撕Linux网络协议栈(四)"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">Fism</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">余思于斯</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/about.html">About</a></li><li class="soc"></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2024&nbsp;<a target="_blank" href="https://fishjump.github.io" rel="noopener noreferrer">Yue Yu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>从内核出发手撕Linux网络协议栈(四)</a></p><p class="post-meta"></p><p class="post-abstract"><h2 id="Bind系统调用的定义"><a href="#Bind系统调用的定义" class="headerlink" title="Bind系统调用的定义"></a>Bind系统调用的定义</h2><p>在上一集，我们讨论了<code>socket</code>系统调用的实现，并且介绍了一些关于阅读Linux内核代码的思路。这一集，我们将会拆解网络协议栈中的<code>bind</code>系统调用。我们首先可以通过<code>man bind</code>命令来查看一下它的函数原型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span><br><span class="line"><span class="params">        	<span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>首先它需要一个<code>sockfd</code>，即我们在<code>socket</code>系统调用中得到的结果。而第二和第三个参数则是传入了我们要绑定的地址。如果仔细阅读<code>man bind</code>中的信息，你可以找到<code>struct sockaddr</code>具体长什么样。下面展示了一个UNIX socket的地址格式，具体类型是<code>struct sockaddr_un</code>。当然我们现在常用的的socket格式还是网络协议相关的，例如TCP和UDP。那么我现在提出一个问题，操作系统是如何完成这么多不同种类的地址格式的兼容的呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">my_addr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_SOCK_PATH <span class="string">&quot;/somepath&quot;</span></span></span><br><span class="line">my_addr.sun_family = AF_UNIX;</span><br><span class="line"><span class="built_in">strncpy</span>(my_addr.sun_path, MY_SOCK_PATH,</span><br><span class="line">		<span class="keyword">sizeof</span>(my_addr.sun_path) - <span class="number">1</span>);</span><br><span class="line">bind(sfd, (<span class="keyword">struct</span> sockaddr *) &amp;my_addr,</span><br><span class="line">            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_un))</span><br></pre></td></tr></table></figure>

<p>我们可以使用正则表达式<code>struct sockaddr.* \&#123;</code>找到所有的地址结构体定义，记得使用工具的时候仅搜索头文件，这样可以大幅缩小查找范围。下面以<code>struct sockaddr</code>，<code>struct sockaddr_un</code>和<code>struct sockaddr_in</code>为例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用address定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span>	sa_family;	<span class="comment">/* address family, AF_xxx	*/</span></span><br><span class="line">	<span class="type">char</span>		sa_data[<span class="number">14</span>];	<span class="comment">/* 14 bytes of protocol address	*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UNIX address定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX	108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">	<span class="type">__kernel_sa_family_t</span> sun_family; <span class="comment">/* AF_UNIX */</span></span><br><span class="line">	<span class="type">char</span> sun_path[UNIX_PATH_MAX];	<span class="comment">/* pathname */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IPv4协议族地址定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">	__be32	s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  <span class="type">__kernel_sa_family_t</span>	sin_family;	<span class="comment">/* Address family		*/</span></span><br><span class="line">  __be16		sin_port;	<span class="comment">/* Port number			*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>	<span class="title">sin_addr</span>;</span>	<span class="comment">/* Internet address		*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>		__pad[__SOCK_SIZE__ - <span class="keyword">sizeof</span>(<span class="type">short</span> <span class="type">int</span>) -</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看见他们的共同点就是第一个元素都存储了自身的协议族。这样，无论这个结构体如何被强转类型，程序都可以获取到协议族信息，并以此来判断传入参数是否正确。此外，可以看见尽管<code>struct sockaddr</code>已经是一个长度明确的结构体，但是<code>bind</code>函数仍然要求传入<code>socklen_t addrlen</code>，可见这组API在设计之时也考虑到了后续的扩展，它允许协议开发者超过通用addr定义的14字节地址长度，就如UNIX address最长可以有108字节。</p>
<p>回到IPv4协议族，它包括了两个要素，IP地址和端口号。其中IP地址是一个<code>uint32</code>的整数，而端口号则是一个<code>uint16</code>的整数。剩余部分的pad，正如注释所述，用于补齐剩余字节，使得<code>struct sockaddr_in</code>和<code>struct sockaddr</code>大小一致。</p>
<h2 id="sys-bind：bind系统调用的入口"><a href="#sys-bind：bind系统调用的入口" class="headerlink" title="__sys_bind：bind系统调用的入口"></a>__sys_bind：bind系统调用的入口</h2><p>使用上一集讲到的方法，我们可以搜索正则表达式<code>&#39;SYSCALL_DEINE.\(bind&#39;</code>来找到bind的实现，如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __sys_bind(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr __user *umyaddr, <span class="type">int</span> addrlen)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">	<span class="type">int</span> err, fput_needed;</span><br><span class="line"></span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">	<span class="keyword">if</span> (sock) &#123;</span><br><span class="line">		err = move_addr_to_kernel(umyaddr, addrlen, &amp;address);</span><br><span class="line">		<span class="keyword">if</span> (err &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			err = security_socket_bind(sock,</span><br><span class="line">						   (<span class="keyword">struct</span> sockaddr *)&amp;address,</span><br><span class="line">						   addrlen);</span><br><span class="line">			<span class="keyword">if</span> (!err)</span><br><span class="line">				err = sock-&gt;ops-&gt;bind(sock,</span><br><span class="line">						      (<span class="keyword">struct</span> sockaddr *)</span><br><span class="line">						      &amp;address, addrlen);</span><br><span class="line">		&#125;</span><br><span class="line">		fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个函数的逻辑还是很好理解的，首先通过<code>sockfd_lookup_light</code>函数，使用<code>fd</code>来查找到绑定的<code>sock</code>。其原理已经在上一集讲过了，简单来说，整个网络协议栈的上层IO都工作在一个VFS（虚拟文件系统）上，当我们试图在socket的VFS上创建一个inode的同时，我们就会创建出一个一一对应的socket。然后，我们再创建一个<code>struct file</code>，与这个inode绑定，并且为其分配一个fd（文件描述符）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> socket *<span class="title function_">sockfd_lookup_light</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> *err, <span class="type">int</span> *fput_needed)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget(fd);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">	*err = -EBADF;</span><br><span class="line">	<span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">		sock = sock_from_file(f.file, err);</span><br><span class="line">		<span class="keyword">if</span> (likely(sock)) &#123;</span><br><span class="line">			*fput_needed = f.flags;</span><br><span class="line">			<span class="keyword">return</span> sock;</span><br><span class="line">		&#125;</span><br><span class="line">		fdput(f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> socket *<span class="title function_">sock_from_file</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">int</span> *err)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (file-&gt;f_op == &amp;socket_file_ops)</span><br><span class="line">		<span class="keyword">return</span> file-&gt;private_data;	<span class="comment">/* set in sock_map_fd */</span></span><br><span class="line"></span><br><span class="line">	*err = -ENOTSOCK;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试进入函数<code>sockfd_lookup_light</code>来验证我们的猜想。可以看见正如我们猜测的那样，首先可以通过<code>fdget</code>来获取到fd所对应的结构体，并且使用<code>sock_from_file</code>来从file中获取到我们的<code>struct socket</code>。倘若我们更进一步进入<code>sock_from_file</code>中，我们会发现其本质就是读取<code>f.file</code>中的<code>private_data</code>，即<code>struct socket</code>的指针，这就是上一集中我们看见<code>sock_alloc_file</code>函数放进去的内容。</p>
<h2 id="inet-bind：IPv4协议族的bind实现"><a href="#inet-bind：IPv4协议族的bind实现" class="headerlink" title="inet_bind：IPv4协议族的bind实现"></a>inet_bind：IPv4协议族的bind实现</h2><p>整个IPv4协议族的<code>bind</code>实现也是极为简单的，除去一些错误处理逻辑外，可以看见逻辑大致可以分为两个分支。</p>
<ol>
<li>如果具体的协议有自己的<code>bind</code>实现，那么使用协议的<code>bind</code>实现；</li>
<li>否则，使用默认的IPv4协议族<code>bind</code>实现。</li>
</ol>
<p>那么假设我们使用了TCP协议，那么会走到哪一条分支呢？在上一集中我们已经知道TCP协议的所有实现可以在<code>tcp_prot</code>这个全局变量中找到，它定义在<code>net/ipv4/tcp_ipv4.c</code>中，由于它太长了直接在文章中贴出来影响观感，这里就不再贴出了。观察这个变量，发现它并没有对<code>bind</code>字段进行赋值，也就是说我们将使用默认的inet_bind实现，<code>__inet_bind</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_bind</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> sockaddr *uaddr, <span class="type">int</span> addr_len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the socket has its own bind function then use it. (RAW) */</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_prot-&gt;bind) &#123;</span><br><span class="line">		<span class="keyword">return</span> sk-&gt;sk_prot-&gt;bind(sk, uaddr, addr_len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* BPF prog is run before any checks are done so that if the prog</span></span><br><span class="line"><span class="comment">	 * changes context in a wrong way it will be caught.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	err = BPF_CGROUP_RUN_PROG_INET4_BIND(sk, uaddr);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __inet_bind(sk, uaddr, addr_len, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="inet-bind：TCP连接真正实现bind的地方"><a href="#inet-bind：TCP连接真正实现bind的地方" class="headerlink" title="__inet_bind：TCP连接真正实现bind的地方"></a>__inet_bind：TCP连接真正实现bind的地方</h2><p>这部分的代码大约有100行，并且没有明显的业务逻辑相关的函数调用，也就是说这个函数本身已经是相当底层了。那么，如果想要真的明白这个函数的含义，我们需要有一点思路并且仔细观察。</p>
<p>我的思路如下：</p>
<ol>
<li>因为<code>bind</code>函数本质上是告诉系统一个socket对应的地址，那么我们可以观察<code>uaddr</code>的去向。</li>
<li>尽管这个函数中有许多赋值和if判断干扰我们的思路，但是如果我们足够敏感的话，可以发现一组加锁和解锁的操作。在操作系统中，这意味着我们真正开始读写有意义的数据了。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __inet_bind(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sockaddr *uaddr, <span class="type">int</span> addr_len,</span><br><span class="line">		<span class="type">bool</span> force_bind_address_no_port, <span class="type">bool</span> with_lock)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span> =</span> (<span class="keyword">struct</span> sockaddr_in *)uaddr;</span><br><span class="line"></span><br><span class="line">	snum = ntohs(addr-&gt;sin_port);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一些赋值和判断操作。。。。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (with_lock)</span><br><span class="line">		lock_sock(sk);</span><br><span class="line"></span><br><span class="line">	inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr = addr-&gt;sin_addr.s_addr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (snum || <span class="comment">/* 一些其他的条件判断 */</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sk-&gt;sk_prot-&gt;get_port(sk, snum)) &#123;</span><br><span class="line">			<span class="comment">// 错误处理</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	inet-&gt;inet_sport = htons(inet-&gt;inet_num);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一些重要的赋值和判断操作。。。。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">out_release_sock:</span><br><span class="line">	<span class="keyword">if</span> (with_lock)</span><br><span class="line">		release_sock(sk);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的思路，我们可以得到这样的一个思路框架，追踪<code>addr</code>的读写情况，我们大概率可以找到想要的内容。仔细阅读代码，可以发现使用<code>addr-&gt;sin_addr</code>的地方相当多，但是使用<code>addr-&gt;sin_port</code>的地方却只有两个，因此我决定从这里入手。通过谷歌可以知道<code>ntohs</code>函数的作用是将网络表达（network）的数据转换为本机表达（host），后缀s表示输出为<code>unsigned short</code>（uint16）类型。之所以需要这个函数是因为，本机的数据大小端是平台有关的，例如x86平台为大端，如<code>0x1234</code>在内存中表达，由低地址向高地址为<code>0x12 0x34</code>。而网络字节序规定传输内容为小端排列，即0x1234应当，由低向高地址表示为<code>0x34 0x12</code>。因此我们需要这样的一个函数来完成数据转换。额外的，arm平台规定用户可以在CPU上配置大小端，例如选择为小端系统，那么这个函数就是应当是一个空函数。类似的函数还有<code>htons</code>，<code>htonl</code>，<code>ntohl</code>，其中l后缀代表<code>unsigned long</code>，即uint32。</p>
<p>在获得了<code>snum</code>之后，我们可以很敏感的发现<code>sk-&gt;sk_prot-&gt;get_port(sk, snum)</code>其实又调用了一个TCP协议的内容，其功能应该是获取端口相关的逻辑。随后，可以发现似乎没有别地方使用端口号了。但是仔细思考，可以做出这样一个猜测，s代表source，而d代表destination。假设如此，那么<code>inet-&gt;inet_sport = htons(inet-&gt;inet_num)</code>很可能就是对端口号的赋值。</p>
<p>这样一来，我们引申出来两个问题：</p>
<ol>
<li><code>snum</code>是如何与<code>inet-&gt;inet_num</code>建立起关联的</li>
<li>为什么给<code>inet</code>赋值就可以完成bind的配置（它似乎只是一个局部变量，我们如何完成数据的持久化？）</li>
</ol>
<p>这两个问题在这个函数中似乎没有很好的回答，那么我们可以先去查看get_port函数。</p>
<h2 id="inet-csk-get-port的实现"><a href="#inet-csk-get-port的实现" class="headerlink" title="inet_csk_get_port的实现"></a>inet_csk_get_port的实现</h2><p>通过查阅<code>tcp_prot</code>结构体，可以发现<code>get_port</code>在TCP协议中的实现为<code>inet_csk_get_port</code>。暂且不讨论其中端口重用的逻辑的话，大体结构如下。整个函数不算短，但是逻辑很清晰。首先可以通过名字知道<code>struct inet_hashinfo *hinfo</code>是一个哈希表，其元数据定义在<code>sk-&gt;sk_prot-&gt;h.hashinfo</code>，即，在这里对应了<code>tcp_prot</code>的<code>h.hashinfo</code>字段。通过跳转，可以发现其就是一个定义在<code>net/ipv4/tcp_ipv4.c</code>的全局变量<code>struct inet_hashinfo tcp_hashinfo</code>。这也就一定程度上解释了操作系统是如何持久化bind的记录。</p>
<p>接下来的逻辑上，假设我们的<code>port</code>为0，那么我们会通过sk来尝试查找返回已经绑定的端口，如果没有则返回错误。这一段显然不是我们正在绑定端口时调用<code>get_port</code>需要的逻辑，而是绑定后查找端口所需的逻辑。</p>
<p>下一段逻辑，通过对<code>port</code>求哈希，加自旋锁（spinlock），然后查找对应和哈希链表上有没有我们想要的端口，如果没有，则创建之，并且返回，这是就是我们正常的主流程。如果有，那么我们则需要进行端口复用，这取决于协议的实现。如果读者愿意回头看看给<code>sk-&gt;sk_reuse</code>赋值的地方，可以发现在<code>inet_create</code>中有一行<code>	if (INET_PROTOSW_REUSE &amp; answer_flags) sk-&gt;sk_reuse = SK_CAN_REUSE;</code>，而<code>answer_flags</code>来自于<code>inetsw_arrary</code>。其中TCP协议对应的flags为<code>INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK</code>，即TCP协议并不原生支持端口复用。这部分逻辑可以忽略。</p>
<p>此处进行一点补充，为了防止有人不知道哈希链表。其本质就是一个哈希表，表中每个元素为一个链表。这样做是因为哈希表有可能会撞哈希，即不同数据有极低概率拥有相同的哈希值，在这种情况下，我们将其用链表串起来。这样的数据结构拥有近似哈希表的速度，因为理想情况下哈希碰撞不会发生或极少发生。但是极端情况下，它会退化成一个链表，即进去的所有元素都发生了哈希碰撞。</p>
<p>接下来，有一个语句很可疑，<code>if (!inet_csk(sk)-&gt;icsk_bind_hash) inet_bind_hash(sk, tb, port);</code>。它与port，port生成的哈希表元素tb，以及sk都有关系，并且函数中提到了inet。那么它很可能和我们之前的疑问有关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_csk_get_port</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">unsigned</span> <span class="type">short</span> snum)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> reuse = sk-&gt;sk_reuse &amp;&amp; sk-&gt;sk_state != TCP_LISTEN;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_hashinfo</span> *<span class="title">hinfo</span> =</span> sk-&gt;sk_prot-&gt;h.hashinfo;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">1</span>, port = snum;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_hashbucket</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_bucket</span> *<span class="title">tb</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">kuid_t</span> uid = sock_i_uid(sk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!port) &#123;</span><br><span class="line">		head = inet_csk_find_open_port(sk, &amp;tb, &amp;port);</span><br><span class="line">		<span class="keyword">if</span> (!head)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		<span class="keyword">if</span> (!tb)</span><br><span class="line">			<span class="keyword">goto</span> tb_not_found;</span><br><span class="line">		<span class="keyword">goto</span> success;</span><br><span class="line">	&#125;</span><br><span class="line">	head = &amp;hinfo-&gt;bhash[inet_bhashfn(net, port,</span><br><span class="line">					  hinfo-&gt;bhash_size)];</span><br><span class="line">	spin_lock_bh(&amp;head-&gt;lock);</span><br><span class="line">	inet_bind_bucket_for_each(tb, &amp;head-&gt;chain)</span><br><span class="line">		<span class="keyword">if</span> (net_eq(ib_net(tb), net) &amp;&amp; tb-&gt;port == port)</span><br><span class="line">			<span class="keyword">goto</span> tb_found;</span><br><span class="line">tb_not_found:</span><br><span class="line">	tb = inet_bind_bucket_create(hinfo-&gt;bind_bucket_cachep,</span><br><span class="line">				     net, head, port);</span><br><span class="line">	<span class="keyword">if</span> (!tb)</span><br><span class="line">		<span class="keyword">goto</span> fail_unlock;</span><br><span class="line">tb_found:</span><br><span class="line">	<span class="comment">// 检查是否可以端口复用</span></span><br><span class="line">	<span class="keyword">if</span> (!hlist_empty(&amp;tb-&gt;owners)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sk-&gt;sk_reuse == SK_FORCE_REUSE)</span><br><span class="line">			<span class="keyword">goto</span> success;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((tb-&gt;fastreuse &gt; <span class="number">0</span> &amp;&amp; reuse) ||</span><br><span class="line">		    sk_reuseport_match(tb, sk))</span><br><span class="line">			<span class="keyword">goto</span> success;</span><br><span class="line">		<span class="keyword">if</span> (inet_csk_bind_conflict(sk, tb, <span class="literal">true</span>, <span class="literal">true</span>))</span><br><span class="line">			<span class="keyword">goto</span> fail_unlock;</span><br><span class="line">	&#125;</span><br><span class="line">success:</span><br><span class="line">	<span class="comment">// 省略端口复用相关的逻辑...</span></span><br><span class="line">	<span class="keyword">if</span> (!inet_csk(sk)-&gt;icsk_bind_hash)</span><br><span class="line">		inet_bind_hash(sk, tb, port);</span><br><span class="line">	WARN_ON(inet_csk(sk)-&gt;icsk_bind_hash != tb);</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_unlock:</span><br><span class="line">	spin_unlock_bh(&amp;head-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入这个函数，我们可以看见<code>snum</code>，即端口号确实赋值给了<code>inet-&gt;inet_num</code>。并且记录了它所对应的哈希表位置。此时，我们应当有意识地意识到<code>inet_sk</code>和<code>inet_csk</code>这两个函数并不简单。进入这两个函数可以发现他们是一个简单的强转，即类似于<code>return (struct inet_sock *)sk</code>这样的形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inet_bind_hash</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> inet_bind_bucket *tb,</span></span><br><span class="line"><span class="params">		    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> snum)</span></span><br><span class="line">&#123;</span><br><span class="line">	inet_sk(sk)-&gt;inet_num = snum;</span><br><span class="line">	sk_add_bind_node(sk, &amp;tb-&gt;owners);</span><br><span class="line">	inet_csk(sk)-&gt;icsk_bind_hash = tb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步地，我们查看<code>struct sock</code>，<code>struct inet_sock</code>和<code>struct inet_connection_sock</code>和定义，可以发现这样的包含关系。并且额外的，作为剧透，我可以告诉读者还有一个<code>tcp_sock</code>套在<code>inet_connection_sock</code>外层。也就是说，我们一直使用的<code>struct sock</code>其实是一个“基类”，而它真正的类型其实是<code>struct tcp_sock</code>（因为我们在&#96;&#96;socket<code>系统调用，</code>sock_create<code>函数中调用</code>pf-&gt;create<code>，调用到了</code>inet_create<code>，其中使用了</code>sk_alloc<code>创建</code>struct sock<code>，并且这个函数知道我们使用的协议。整个逻辑链很清晰，感兴趣的读者可以自行阅读，最终可以看见底层是函数根据</code>tcp_prot<code>中的</code>obj_size<code>来进行</code>kmalloc<code>，而</code>obj_size &#x3D; sizeof(struct tcp_sock)&#96;。使用这样的技巧，C语言可以实现一些面向对象中继承的特性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span>		<span class="title">sk</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span>	  <span class="title">icsk_inet</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span>	  <span class="title">inet_conn</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="小结：让我们回到-inet-bind"><a href="#小结：让我们回到-inet-bind" class="headerlink" title="小结：让我们回到__inet_bind"></a>小结：让我们回到__inet_bind</h2><p>至此，我们应该已经可以回答之前提出的两个问题。<code>bind</code>函数本质上只是将地址和端口存入全局变量中。地址会被放入内存堆上的<code>struct sock *sk</code>中，而端口除了会被放在sk中，还会放在一个全局的哈希表中，用于快速查找是否有重复的端口占用。这些数据通过<code>struct sock *sk</code>串联起来。而其也不是一个简单的<code>struct sock</code>，本质上是一个<code>struct tcp_sock</code>对象，我们针对不同函数，有限度地将其强转为不同层次所需要的结构。总的来说，<code>bind</code>的实现是相当简单的，仅仅涉及到一些全局变量的读写操作。</p>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=https://fishjump.github.io//posts/linux-kernel-net-04/%20余思于斯 - Fism%20从内核出发手撕Linux网络协议栈(四)"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/posts/linux-kernel-net-03/" title="从内核出发手撕Linux网络协议栈(三)"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 从内核出发手撕Linux网络协议栈(三)</a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2024&nbsp;<a target="_blank" href="https://fishjump.github.io" rel="noopener noreferrer">Yue Yu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>