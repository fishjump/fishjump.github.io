<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>从内核出发手撕Linux网络协议栈(五) · 余思于斯 - Fism</title><meta name="description" content="（最近在外地，没有自己的PC，只能周末腹泻式更新）
Listen系统调用昨天介绍了bind系统调用，下一步就是listen系统调用了。它的参数很简单，只有两个。第一个是int fd，读者想必已经非常熟悉了，就是我们socket所对应的文件描述符；而第二个参数则是代表了最大连接请求等待队列的长度。也就"><meta name="og:description" content="（最近在外地，没有自己的PC，只能周末腹泻式更新）
Listen系统调用昨天介绍了bind系统调用，下一步就是listen系统调用了。它的参数很简单，只有两个。第一个是int fd，读者想必已经非常熟悉了，就是我们socket所对应的文件描述符；而第二个参数则是代表了最大连接请求等待队列的长度。也就"><meta name="twitter:site" content="余思于斯 - Fism"><meta name="twitter:title" content="从内核出发手撕Linux网络协议栈(五)"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">Fism</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">余思于斯</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/about.html">About</a></li><li class="soc"></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2024&nbsp;<a target="_blank" href="https://fishjump.github.io" rel="noopener noreferrer">Yue Yu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>从内核出发手撕Linux网络协议栈(五)</a></p><p class="post-meta"></p><p class="post-abstract"><p>（最近在外地，没有自己的PC，只能周末腹泻式更新）</p>
<h2 id="Listen系统调用"><a href="#Listen系统调用" class="headerlink" title="Listen系统调用"></a>Listen系统调用</h2><p>昨天介绍了<code>bind</code>系统调用，下一步就是<code>listen</code>系统调用了。它的参数很简单，只有两个。第一个是<code>int fd</code>，读者想必已经非常熟悉了，就是我们socket所对应的文件描述符；而第二个参数则是代表了最大连接请求等待队列的长度。也就是在<code>listen</code>完成之后，如果同一时间有多台主机向服务器发起连接请求，那么服务器允许的最大队列长度。同样地，以上介绍读者都可以通过<code>man listen</code>命令自行查阅，以证明我不是在乱说。</p>
<p>接着，让我们使用同样的方法，搜索<code>&quot;SYSCALL_DEFINE.\(listen&quot;</code>来找到<code>listen</code>函数的入口，如下所示。其中<code>sockfd_lookup_light</code>已经在上一集中介绍过了，其作用是给定一个<code>fd</code>，找到其所对应的<code>struct socket</code>对象。</p>
<p>紧接着，如果我们给定的<code>backlog</code>超过了系统所允许的上限，那么以系统的参数为准。这里可以稍微进行一下扩展，<code>somaxconn</code>代表了socket max connection，这是一个内核参数。我们有两种办法可以修改这个参数。</p>
<ol>
<li>我们可以直接修改对应的文件，例如修改为2048，<code>echo 2048 &gt; /proc/sys/net/core/somaxconn</code>。这样的修改是临时的，当系统重启之后就会失效。</li>
<li>我们可以在<code>/etc/sysctl.conf</code>文件中进行修改，加上或者修改现有配置为<code>net.core.somaxconn = 2048</code>，重启后生效。或者使用命令<code>sysctl -w net.core.somaxconn=2048 &gt;&gt; /etc/sysctl.conf</code>，更改会立即并永久生效，无需重启。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __sys_listen(<span class="type">int</span> fd, <span class="type">int</span> backlog)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="type">int</span> err, fput_needed;</span><br><span class="line">	<span class="type">int</span> somaxconn;</span><br><span class="line"></span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">	<span class="keyword">if</span> (sock) &#123;</span><br><span class="line">		somaxconn = sock_net(sock-&gt;sk)-&gt;core.sysctl_somaxconn;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">int</span>)backlog &gt; somaxconn)</span><br><span class="line">			backlog = somaxconn;</span><br><span class="line"></span><br><span class="line">		err = security_socket_listen(sock, backlog);</span><br><span class="line">		<span class="keyword">if</span> (!err)</span><br><span class="line">			err = sock-&gt;ops-&gt;listen(sock, backlog);</span><br><span class="line"></span><br><span class="line">		fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE2(listen, <span class="type">int</span>, fd, <span class="type">int</span>, backlog)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sys_listen(fd, backlog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="inet-listen的实现"><a href="#inet-listen的实现" class="headerlink" title="inet_listen的实现"></a>inet_listen的实现</h2><p>通过和之前一样的方法，找到<code>inetsw_array</code>中TCP的数组，listen中的<code>sock-&gt;ops-&gt;listen</code>对应了<code>inet_stream_ops-&gt;listen</code>，即<code>inet_listen</code>。可以看见其的内部实现也相对简单，首先我们判断这个socket是否是未连接状态（<code>sock-&gt;state != SS_UNCONNECTED</code>），并且它是不是有连接的socket（<code>sock-&gt;type != SOCK_STREAM</code>）。如果已经连接或者socket类型就不对，那么自然是退出。</p>
<p>然后判断<code>struct sock sk</code>当前的状态，如果已经是<code>TCP_CLOSE</code>或者<code>TCP_LISTEN</code>那么也是错误的状态，需要退出。这里有一个小细节，那就是代码中使用了<code>TCPF_CLOSE</code>和<code>TCPF_LISTEN</code>的位运算来判断，其中F代表Flag，这样做可以加速运算。跳转到<code>include/net/tcp_states.h</code>可以看见TCPF_XXX的定义就是(1 &lt;&lt; TCP_XXX)。例如<code>TCPF_ESTABLISHED = (1 &lt;&lt; TCP_ESTABLISHED)</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	TCP_ESTABLISHED = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 其他定义。。。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	TCPF_ESTABLISHED = (<span class="number">1</span> &lt;&lt; TCP_ESTABLISHED),</span><br><span class="line">    <span class="comment">// 其他定义。。。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后的if判断中大部分是和tcp_fastopen相关的实现，这一段可以暂时跳过，核心业务逻辑代码其实只有一行<code>inet_csk_listen_start</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_listen</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> old_state;</span><br><span class="line">	<span class="type">int</span> err, tcp_fastopen;</span><br><span class="line"></span><br><span class="line">	lock_sock(sk);</span><br><span class="line"></span><br><span class="line">	err = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;state != SS_UNCONNECTED || sock-&gt;type != SOCK_STREAM)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	old_state = sk-&gt;sk_state;</span><br><span class="line">	<span class="keyword">if</span> (!((<span class="number">1</span> &lt;&lt; old_state) &amp; (TCPF_CLOSE | TCPF_LISTEN)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Really, if the socket is already in listen state</span></span><br><span class="line"><span class="comment">	 * we can only allow the backlog to be adjusted.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (old_state != TCP_LISTEN) &#123;</span><br><span class="line">		<span class="comment">/* Enable TFO w/o requiring TCP_FASTOPEN socket option.</span></span><br><span class="line"><span class="comment">		 * Note that only TCP sockets (SOCK_STREAM) will reach here.</span></span><br><span class="line"><span class="comment">		 * Also fastopen backlog may already been set via the option</span></span><br><span class="line"><span class="comment">		 * because the socket was in TCP_LISTEN state previously but</span></span><br><span class="line"><span class="comment">		 * was shutdown() rather than close().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		tcp_fastopen = sock_net(sk)-&gt;ipv4.sysctl_tcp_fastopen;</span><br><span class="line">		<span class="keyword">if</span> ((tcp_fastopen &amp; TFO_SERVER_WO_SOCKOPT1) &amp;&amp;</span><br><span class="line">		    (tcp_fastopen &amp; TFO_SERVER_ENABLE) &amp;&amp;</span><br><span class="line">		    !inet_csk(sk)-&gt;icsk_accept_queue.fastopenq.max_qlen) &#123;</span><br><span class="line">			fastopen_queue_tune(sk, backlog);</span><br><span class="line">			tcp_fastopen_init_key_once(sock_net(sk));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = inet_csk_listen_start(sk, backlog);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		tcp_call_bpf(sk, BPF_SOCK_OPS_TCP_LISTEN_CB, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	sk-&gt;sk_max_ack_backlog = backlog;</span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	release_sock(sk);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="inet-csk-listen-start的实现"><a href="#inet-csk-listen-start的实现" class="headerlink" title="inet_csk_listen_start的实现"></a>inet_csk_listen_start的实现</h2><p>可以看见这里再次用到了icsk和inet，也就是sk的上层封装。这个函数的前半段主要进行一些初始化操作，设置了等待队列。紧接着，最关键的一行是<code>inet_sk_state_store(sk, TCP_LISTEN)</code>，它将我们socket的状态设置为<code>TCP_LISTEN</code>，代表我们的socket已经允许接受外部的连接。</p>
<p>这时候，我们再次尝试获取端口号，如果成功，那么就listen成功。否则，我们重新将sk的状态设置为<code>TCP_CLOSE</code>并且返回错误。额外的，可以看注释说明的，这里其实有一个竞争窗口，如果有其他进程也在访问<code>get_port</code>会发生什么事？其实我们不用担心，因为在<code>get_port</code>当中调用了<code>spin_lock_bh</code>自旋锁，又或者其他协议的<code>get_port</code>有义务保证其自身的线程安全。</p>
<p>这里可以还引出一个疑问，即我们已经在<code>bind</code>中调用过<code>inet_csk_get_port</code>了，为什么这里还需要再使用一次<code>get_port</code>？原因其实很简单，linux中允许端口复用。假设我们设置允许端口复用，此时，另一个进程也以允许重用的方式<code>bind</code>了相同的端口，并且以更快的速度完成了<code>listen</code>。那么此时，这个端口就被完全占用直到其被释放。此时，尽管我们之前<code>bind</code>成功，我们也无法完成<code>listen</code>。具体的逻辑可以查看<code>inet_csk_bind_conflict</code>函数，它被定义在<code>net/ipv4/inet_connection_sock.c</code>中，由<code>inet_csk_get_port</code>调用。</p>
<p>假设我们成功完成了<code>get_port</code>，下一步我们将会将我们sk放入到TCP协议的全局hash表中。这里的hash表和bind中的不同，让我们看看<code>sk-&gt;sk_prot-&gt;hash</code>函数的定义（也就是<code>inet_hash</code>）和<code>bind</code>中使用的哈希表的区别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_csk_listen_start</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line">	<span class="type">int</span> err = -EADDRINUSE;</span><br><span class="line"></span><br><span class="line">	reqsk_queue_alloc(&amp;icsk-&gt;icsk_accept_queue);</span><br><span class="line"></span><br><span class="line">	sk-&gt;sk_max_ack_backlog = backlog;</span><br><span class="line">	sk-&gt;sk_ack_backlog = <span class="number">0</span>;</span><br><span class="line">	inet_csk_delack_init(sk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* There is race window here: we announce ourselves listening,</span></span><br><span class="line"><span class="comment">	 * but this transition is still not validated by get_port().</span></span><br><span class="line"><span class="comment">	 * It is OK, because this socket enters to hash table only</span></span><br><span class="line"><span class="comment">	 * after validation is complete.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	inet_sk_state_store(sk, TCP_LISTEN);</span><br><span class="line">	<span class="keyword">if</span> (!sk-&gt;sk_prot-&gt;get_port(sk, inet-&gt;inet_num)) &#123;</span><br><span class="line">		inet-&gt;inet_sport = htons(inet-&gt;inet_num);</span><br><span class="line"></span><br><span class="line">		sk_dst_reset(sk);</span><br><span class="line">		err = sk-&gt;sk_prot-&gt;hash(sk);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(!err))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	inet_sk_set_state(sk, TCP_CLOSE);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="inet-hash的实现"><a href="#inet-hash的实现" class="headerlink" title="inet_hash的实现"></a>inet_hash的实现</h2><p><code>inet_hash</code>的主要逻辑实现在<code>__inet_hash</code>当中。可以看见和bind中不同，bind中将数据放入到哈希表发生在<code>get_port</code>函数中，即<code>inet_csk_get_port</code>，将数据写入<code>bhash</code>。而<code>inet_hash</code>主要将数据写入<code>listening_hash</code>。更进一步地，进入到<code>inet_hash2</code>函数的实现中，另一部分的数据写入了<code>lhash2</code>哈希表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">inet_hash2</span><span class="params">(<span class="keyword">struct</span> inet_hashinfo *h, <span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_listen_hashbucket</span> *<span class="title">ilb2</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!h-&gt;lhash2)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	ilb2 = inet_lhash2_bucket_sk(h, sk);</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;ilb2-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_reuseport &amp;&amp; sk-&gt;sk_family == AF_INET6)</span><br><span class="line">		hlist_add_tail_rcu(&amp;inet_csk(sk)-&gt;icsk_listen_portaddr_node,</span><br><span class="line">				   &amp;ilb2-&gt;head);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		hlist_add_head_rcu(&amp;inet_csk(sk)-&gt;icsk_listen_portaddr_node,</span><br><span class="line">				   &amp;ilb2-&gt;head);</span><br><span class="line">	ilb2-&gt;count++;</span><br><span class="line">	spin_unlock(&amp;ilb2-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __inet_hash(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sock *osk)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_hashinfo</span> *<span class="title">hashinfo</span> =</span> sk-&gt;sk_prot-&gt;h.hashinfo;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_listen_hashbucket</span> *<span class="title">ilb</span>;</span></span><br><span class="line">	<span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state != TCP_LISTEN) &#123;</span><br><span class="line">		inet_ehash_nolisten(sk, osk);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	WARN_ON(!sk_unhashed(sk));</span><br><span class="line">	ilb = &amp;hashinfo-&gt;listening_hash[inet_sk_listen_hashfn(sk)];</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;ilb-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_reuseport) &#123;</span><br><span class="line">		err = inet_reuseport_add_sock(sk, ilb);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_IPV6) &amp;&amp; sk-&gt;sk_reuseport &amp;&amp;</span><br><span class="line">		sk-&gt;sk_family == AF_INET6)</span><br><span class="line">		hlist_add_tail_rcu(&amp;sk-&gt;sk_node, &amp;ilb-&gt;head);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		hlist_add_head_rcu(&amp;sk-&gt;sk_node, &amp;ilb-&gt;head);</span><br><span class="line">	inet_hash2(hashinfo, sk);</span><br><span class="line">	ilb-&gt;count++;</span><br><span class="line">	sock_set_flag(sk, SOCK_RCU_FREE);</span><br><span class="line">	sock_prot_inuse_add(sock_net(sk), sk-&gt;sk_prot, <span class="number">1</span>);</span><br><span class="line">unlock:</span><br><span class="line">	spin_unlock(&amp;ilb-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以直接查看<code>struct inet_hashinfo</code>的定义。可以看见这个哈希表主要由三部分构成，分别是已经建立连接状态的socket的哈希表，已经bind的，和已经进入listen状态的。那么此时我们又要提出另外一个问题，为什么我们需要两个listening哈希表呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_hashinfo</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_ehash_bucket</span>	*<span class="title">ehash</span>;</span></span><br><span class="line">	<span class="type">spinlock_t</span>			*ehash_locks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			ehash_mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			ehash_locks_mask;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span>		*<span class="title">bind_bucket_cachep</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_hashbucket</span>	*<span class="title">bhash</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			bhash_size;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			lhash2_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_listen_hashbucket</span>	*<span class="title">lhash2</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_listen_hashbucket</span>	<span class="title">listening_hash</span>[<span class="title">INET_LHTABLE_SIZE</span>]</span></span><br><span class="line"><span class="class">					____<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这其实是有历史原因的，在过去，Linux的listening哈希表只使用端口号来做hash。如下面代码，如果没有配置<code>CONFIG_NET_NS</code>，即网络命名空间，哈希函数的结果就只取决于端口号。<code>inet_sk_listen_hashfn</code>在<code>__inet_hash</code>中被调用。在过去，这个行为就还好，无非是监听不同IP地址的相同端口时会出现哈希碰撞。但是在加入端口重用之后，哈希碰撞的问题变得严重，哈希表常常退化成一个链表。这样一来，为了性能引入了<code>lhash2</code>。同时，为了兼容性，保留了<code>listening_hash</code>。可以看见在第二版实现中，同时计算了地址和端口，加强了哈希随机性，使得哈希桶的占用情况更加均匀。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版listening hashtable的哈希函数</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u32 <span class="title function_">net_hash_mix</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> net *net)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_NS</span></span><br><span class="line">	<span class="keyword">return</span> (u32)(((<span class="type">unsigned</span> <span class="type">long</span>)net) &gt;&gt; ilog2(<span class="keyword">sizeof</span>(*net)));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u32 <span class="title function_">inet_lhashfn</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (num + net_hash_mix(net)) &amp; (INET_LHTABLE_SIZE - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">inet_sk_listen_hashfn</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> inet_lhashfn(sock_net(sk), inet_sk(sk)-&gt;inet_num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二版listening hashtable的哈希函数</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inet_listen_hashbucket *</span><br><span class="line"><span class="title function_">inet_lhash2_bucket_sk</span><span class="params">(<span class="keyword">struct</span> inet_hashinfo *h, <span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 hash;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_IPV6)</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_family == AF_INET6)</span><br><span class="line">		hash = ipv6_portaddr_hash(sock_net(sk),</span><br><span class="line">					  &amp;sk-&gt;sk_v6_rcv_saddr,</span><br><span class="line">					  inet_sk(sk)-&gt;inet_num);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		hash = ipv4_portaddr_hash(sock_net(sk),</span><br><span class="line">					  inet_sk(sk)-&gt;inet_rcv_saddr,</span><br><span class="line">					  inet_sk(sk)-&gt;inet_num);</span><br><span class="line">	<span class="keyword">return</span> inet_lhash2_bucket(h, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="listen系统调用小结"><a href="#listen系统调用小结" class="headerlink" title="listen系统调用小结"></a>listen系统调用小结</h2><p>总的来说，<code>listen</code>的实现相当简单。首先还是通过<code>fd</code>来找到对应的socket。在拿到socket后，将其设置为<code>TCP_LISTEN</code>状态，尝试再次占用它的端口确保没有任何竞争状态发生，并且调用hash函数将其写入到listening hashtable当中。其中我们还涉及到了listening hashtable的一些历史遗留问题。如果尝试再次获取端口失败，则将socket重置为<code>TCP_CLOSE</code>状态，并且返回错误。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>设置somaxconn：()[<a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/managing_monitoring_and_updating_the_kernel/configuring-kernel-parameters-permanently-with-sysctl_configuring-kernel-parameters-at-runtime]">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/managing_monitoring_and_updating_the_kernel/configuring-kernel-parameters-permanently-with-sysctl_configuring-kernel-parameters-at-runtime]</a></p>
<p>lhash2的历史背景：()[<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020536287]">https://segmentfault.com/a/1190000020536287]</a></p>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=https://fishjump.github.io//posts/linux-kernel-net-05/%20余思于斯 - Fism%20从内核出发手撕Linux网络协议栈(五)"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/posts/linux-kernel-net-04/" title="从内核出发手撕Linux网络协议栈(四)"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 从内核出发手撕Linux网络协议栈(四)</a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2024&nbsp;<a target="_blank" href="https://fishjump.github.io" rel="noopener noreferrer">Yue Yu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>