<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>从内核出发手撕Linux网络协议栈(六) · 余思于斯 - Fism</title><meta name="description" content="（从外地回来赶上周天调休，鸽了一周）我自己又反复读了一下我的内容，感觉直接贴出长篇的代码有点不利于理解，这次尝试代码分段讲解。有兴趣的朋友也可以自己去网上找到完整的源码，以便查证我贴出来的内容是不是在断章取义。
Accept系统调用这次让我们来学习accept系统调用，这个系统调用的形式如下，soc"><meta name="og:description" content="（从外地回来赶上周天调休，鸽了一周）我自己又反复读了一下我的内容，感觉直接贴出长篇的代码有点不利于理解，这次尝试代码分段讲解。有兴趣的朋友也可以自己去网上找到完整的源码，以便查证我贴出来的内容是不是在断章取义。
Accept系统调用这次让我们来学习accept系统调用，这个系统调用的形式如下，soc"><meta name="twitter:site" content="余思于斯 - Fism"><meta name="twitter:title" content="从内核出发手撕Linux网络协议栈(六)"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">Fism</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">余思于斯</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/about.html">About</a></li><li class="soc"></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2024&nbsp;<a target="_blank" href="https://fishjump.github.io" rel="noopener noreferrer">Yue Yu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>从内核出发手撕Linux网络协议栈(六)</a></p><p class="post-meta"></p><p class="post-abstract"><p>（从外地回来赶上周天调休，鸽了一周）<br>我自己又反复读了一下我的内容，感觉直接贴出长篇的代码有点不利于理解，这次尝试代码分段讲解。有兴趣的朋友也可以自己去网上找到完整的源码，以便查证我贴出来的内容是不是在断章取义。</p>
<h2 id="Accept系统调用"><a href="#Accept系统调用" class="headerlink" title="Accept系统调用"></a>Accept系统调用</h2><p>这次让我们来学习accept系统调用，这个系统调用的形式如下，sockfd即服务器的socket，而参数struct sockaddr *addr与socklen_t *addrlen是对应类型的指针，用于获取客户端的IP。额外的，accept4是拥有四个参数的accept，第四个参数flags有两个可能的选项（可以使用按位或，即<code>|</code>，来进行多选），如果flags为0，那么表现和accept一样。</p>
<ol>
<li>SOCK_NONBLOCK：它很好理解，即客户端的socket（即accept的返回值）将被设置为非阻塞模式，如果没有连接请求到达，那么它会立即返回错误<code>EAGAIN</code>。</li>
<li>SOCK_CLOEXEC：这个flag代表close-on-exec，那么我们创建的客户端socket将会自动在成功调用fork或者exec系列函数的时候被关闭。这样做可以防止文件描述符（fd）被意外泄漏给子线程&#x2F;进程，从而导致数据竞争或者其他问题。</li>
</ol>
<p>accept逻辑上用于服务器接收客户端发送来的数据。实质上，这个函数并没有从“客户端”接收数据，而是从网卡驱动给定的缓冲区读取数据。现在让我们来具体了解一下这个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">accept4</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="sys-accept4的实现"><a href="#sys-accept4的实现" class="headerlink" title="__sys_accept4的实现"></a>__sys_accept4的实现</h2><p>利用之前几篇文章所讲到的方法，我们已经可以快速定位到accept系统调用的实现是__sys_accept4函数。其主流程非常清晰。首先，我们还是尝试从fd获取到对应的socket。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line"><span class="keyword">if</span> (!sock)</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>

<p>然后我们会创建一个新的socket，即客户端的socket连接，并且复制客户端的类型（socket连接类型，例如TCP是SOCK_STREAM）和操作（即SOCK_STREAM类型协议会用到的函数指针的集合）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">newsock = sock_alloc();</span><br><span class="line"><span class="keyword">if</span> (!newsock)</span><br><span class="line">	<span class="keyword">goto</span> out_put;</span><br><span class="line"></span><br><span class="line">newsock-&gt;type = sock-&gt;type;</span><br><span class="line">newsock-&gt;ops = sock-&gt;ops; </span><br></pre></td></tr></table></figure>

<p>接下来，类似于socket系统调用中我们创建新的服务器socket，这里我们也要为客户端socket分配fd和创建file对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">newfd = get_unused_fd_flags(flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(newfd &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">	err = newfd;</span><br><span class="line">	sock_release(newsock);</span><br><span class="line">	<span class="keyword">goto</span> out_put;</span><br><span class="line">&#125;</span><br><span class="line">newfile = sock_alloc_file(newsock, flags, sock-&gt;sk-&gt;sk_prot_creator-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(newfile)) &#123;</span><br><span class="line">	err = PTR_ERR(newfile);</span><br><span class="line">	put_unused_fd(newfd);</span><br><span class="line">	<span class="keyword">goto</span> out_put;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后，我们会调用sock-&gt;ops-&gt;accept来接受数据，也就是之前提到过很多次的inetsw_array中TCP所对应的元素的ops，在这里是inet_accept。sock即我们的服务器socket，newsock是我们的客户端socket，f_flags即我们之前的flags，在函数调用sock_alloc_file中赋值给了file。感兴趣的读者可以自行一层一层翻下去，还是很好找到这一行的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">err = sock-&gt;ops-&gt;accept(sock, newsock, sock-&gt;file-&gt;f_flags, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">goto</span> out_fd;</span><br></pre></td></tr></table></figure>

<p>最后，内核会检测用户传入的socket地址是否合法（不为NULL），如果不为NULL的话，那么就把内核态的客户端地址信息拷贝到用户空间。当然从代码可以看出，用户如果选择了传入NULL也没事，这并不会导致返回错误，仅代表用户不关心这个数据。结尾处，我们同样如同第一章介绍socket_create时那样，将fd和file关联起来，并且返回fd的值。至此accept的主流程就完成了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (upeer_sockaddr) &#123;</span><br><span class="line">	len = newsock-&gt;ops-&gt;getname(newsock,</span><br><span class="line">				(<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err = -ECONNABORTED;</span><br><span class="line">		<span class="keyword">goto</span> out_fd;</span><br><span class="line">	&#125;</span><br><span class="line">	err = move_addr_to_user(&amp;address,</span><br><span class="line">				len, upeer_sockaddr, upeer_addrlen);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* File flags are not inherited via accept() unlike another OSes. */</span></span><br><span class="line"></span><br><span class="line">fd_install(newfd, newfile);</span><br><span class="line">err = newfd;</span><br></pre></td></tr></table></figure>

<h2 id="inet-accept的实现（sock-ops-accept）"><a href="#inet-accept的实现（sock-ops-accept）" class="headerlink" title="inet_accept的实现（sock-&gt;ops-&gt;accept）"></a>inet_accept的实现（sock-&gt;ops-&gt;accept）</h2><p>上面走完了__sys_accept的主流程，现在让我们来它的实现。函数一开始创建了两个sock，sk1从sock得到，而sk2则是调用tcp协议的accept获取。我们同样可以从inetsw_array中找到，这个函数为inet_csk_accept，我们等会介绍。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_accept</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> socket *newsock, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">bool</span> kern)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk1</span> =</span> sock-&gt;sk;</span><br><span class="line">	<span class="type">int</span> err = -EINVAL;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk2</span> =</span> sk1-&gt;sk_prot-&gt;accept(sk1, flags, &amp;err, kern);</span><br><span class="line">	<span class="comment">// 剩余代码 ...</span></span><br></pre></td></tr></table></figure>

<p>接下来的代码就是给sk2加锁，并且将sk2赋值给newsock-&gt;sk，这一步在sock_graft中实现。然后将newsock的状态设置为CONNECTED。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!sk2)</span><br><span class="line">	<span class="keyword">goto</span> do_err;</span><br><span class="line"></span><br><span class="line">lock_sock(sk2);</span><br><span class="line"></span><br><span class="line">sock_rps_record_flow(sk2);</span><br><span class="line">WARN_ON(!((<span class="number">1</span> &lt;&lt; sk2-&gt;sk_state) &amp;</span><br><span class="line">	  (TCPF_ESTABLISHED | TCPF_SYN_RECV |</span><br><span class="line">	  TCPF_CLOSE_WAIT | TCPF_CLOSE)));</span><br><span class="line"></span><br><span class="line">sock_graft(sk2, newsock);</span><br><span class="line"></span><br><span class="line">newsock-&gt;state = SS_CONNECTED;</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line">release_sock(sk2);</span><br></pre></td></tr></table></figure>

<p>我们可以来看看sock_graft的实现，除去加锁之外，主要就是将socket和sock联系起来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">sock_graft</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> socket *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	WARN_ON(parent-&gt;sk);</span><br><span class="line">	write_lock_bh(&amp;sk-&gt;sk_callback_lock);</span><br><span class="line">	rcu_assign_pointer(sk-&gt;sk_wq, parent-&gt;wq);</span><br><span class="line">	parent-&gt;sk = sk;</span><br><span class="line">	sk_set_socket(sk, parent);</span><br><span class="line">	sk-&gt;sk_uid = SOCK_INODE(parent)-&gt;i_uid;</span><br><span class="line">	security_sock_graft(sk, parent);</span><br><span class="line">	write_unlock_bh(&amp;sk-&gt;sk_callback_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="inet-csk-accept的实现（sk1-sk-prot-accept）"><a href="#inet-csk-accept的实现（sk1-sk-prot-accept）" class="headerlink" title="inet_csk_accept的实现（sk1-&gt;sk_prot-&gt;accept）"></a>inet_csk_accept的实现（sk1-&gt;sk_prot-&gt;accept）</h2><p>除去开头的变量创建之外，首先我们是加锁并且判断sk当前的状态时LISTEN，这一步是为了防止连接在其他线程被断掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock_sock(sk);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We need to make sure that this socket is listening,</span></span><br><span class="line"><span class="comment"> * and that it has something pending.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_state != TCP_LISTEN)</span><br><span class="line">	<span class="keyword">goto</span> out_err;</span><br></pre></td></tr></table></figure>

<p>下一步，我们需要从等待连接队列中取出sock并建立连接，并且将其赋值给newsk。其中reqsk_queue_empty判断等待队列是否为空。若为空则在inet_csk_wait_for_connect函数中进行等待，其中timeo为timeout的缩写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (reqsk_queue_empty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">	<span class="type">long</span> timeo = sock_rcvtimeo(sk, flags &amp; O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If this is a non blocking socket don&#x27;t sleep */</span></span><br><span class="line">	error = -EAGAIN;</span><br><span class="line">	<span class="keyword">if</span> (!timeo)</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	error = inet_csk_wait_for_connect(sk, timeo);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line">&#125;</span><br><span class="line">req = reqsk_queue_remove(<span class="built_in">queue</span>, sk);</span><br><span class="line">newsk = req-&gt;sk;</span><br></pre></td></tr></table></figure>

<p>到此，inet_csk_accept的主流程就已经完毕。下一步让我们看看inet_csk_wait_for_connect的实现。</p>
<h2 id="inet-csk-wait-for-connect的实现"><a href="#inet-csk-wait-for-connect的实现" class="headerlink" title="inet_csk_wait_for_connect的实现"></a>inet_csk_wait_for_connect的实现</h2><p>inet_csk_wait_for_connect的实现相当直观，其中比较tricky的部分是schedule函数，这部分逻辑涉及到任务调度方面的源码，我们可以暂且跳过。它的大概功能是，schedule使得当前线程休眠直到某个调度点到来。这个调度点是由唤醒函数决定的，它被定义在DEFINE_WAIT宏中，在这里是autoremove_wake_function。通常来说，当驱动程序完成了一个I&#x2F;O操作时，就会调用唤醒函数来唤醒正在等待的进程。</p>
<p>当我们从schedule_timeout返回时，检测等待队列中是否有需要连接的客户端请求。如果有，整个流程结束并且使用finish_wait从等待队列中删除当前进程上下文。如果没有，那么考虑如果sock当前状态不为TCP_LISTEN或者timeo为0，即已经超时。这时候设置对应的错误码并且结束等待并返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">inet_csk_wait_for_connect</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">long</span> timeo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">	DEFINE_WAIT(wait);</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		prepare_to_wait_exclusive(sk_sleep(sk), &amp;wait,</span><br><span class="line">					  TASK_INTERRUPTIBLE);</span><br><span class="line">		release_sock(sk);</span><br><span class="line">		<span class="keyword">if</span> (reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))</span><br><span class="line">			timeo = schedule_timeout(timeo);</span><br><span class="line">		sched_annotate_sleep();</span><br><span class="line">		lock_sock(sk);</span><br><span class="line">		err = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (sk-&gt;sk_state != TCP_LISTEN)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		err = sock_intr_errno(timeo);</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		err = -EAGAIN;</span><br><span class="line">		<span class="keyword">if</span> (!timeo)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	finish_wait(sk_sleep(sk), &amp;wait);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此为止整个accept的流程已经走完。总的来说它简单的创建了一个新的客户端socket并且等待更底层的代码将可以连接的程序放入icsk_accept_queue这个队列中。到此为止读者肯定也不太满足，这部分放入队列的逻辑肯定也是大家最关心的逻辑。我计划将会在介绍完connect之后深入更底层的内容。</p>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=https://fishjump.github.io//posts/linux-kernel-net-06/%20余思于斯 - Fism%20从内核出发手撕Linux网络协议栈(六)"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/posts/linux-kernel-net-05/" title="从内核出发手撕Linux网络协议栈(五)"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 从内核出发手撕Linux网络协议栈(五)</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/posts/linux-kernel-net-07/" title="从内核出发手撕Linux网络协议栈(七)">Next post: 从内核出发手撕Linux网络协议栈(七)&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2024&nbsp;<a target="_blank" href="https://fishjump.github.io" rel="noopener noreferrer">Yue Yu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>