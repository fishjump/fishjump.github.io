<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>从内核出发手撕Linux网络协议栈(二) · 余思于斯 - Fism</title><meta name="description" content="孔乙己: 系统调用的调用有四种写法既然这个系列是从源码开始手撕Linux网络协议栈，那么不妨先了解一下Linux的系统调用是如何发生的，然后尝试自己给Linux添加一个系统调用，以便之后更容易了解和学习网络模块的内核实现。
以一个简单的例子开始，以下是一个常规的Hello World。尝试编译这个程"><meta name="og:description" content="孔乙己: 系统调用的调用有四种写法既然这个系列是从源码开始手撕Linux网络协议栈，那么不妨先了解一下Linux的系统调用是如何发生的，然后尝试自己给Linux添加一个系统调用，以便之后更容易了解和学习网络模块的内核实现。
以一个简单的例子开始，以下是一个常规的Hello World。尝试编译这个程"><meta name="twitter:site" content="余思于斯 - Fism"><meta name="twitter:title" content="从内核出发手撕Linux网络协议栈(二)"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">Fism</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">余思于斯</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/about.html">About</a></li><li class="soc"></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2024&nbsp;<a target="_blank" href="https://fishjump.github.io" rel="noopener noreferrer">Yue Yu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>从内核出发手撕Linux网络协议栈(二)</a></p><p class="post-meta"></p><p class="post-abstract"><h2 id="孔乙己-系统调用的调用有四种写法"><a href="#孔乙己-系统调用的调用有四种写法" class="headerlink" title="孔乙己: 系统调用的调用有四种写法"></a>孔乙己: 系统调用的调用有四种写法</h2><p>既然这个系列是从源码开始手撕Linux网络协议栈，那么不妨先了解一下Linux的系统调用是如何发生的，然后尝试自己给Linux添加一个系统调用，以便之后更容易了解和学习网络模块的内核实现。</p>
<p>以一个简单的例子开始，以下是一个常规的Hello World。尝试编译这个程序并运行会毫不意外的看到控制台输出了<code>Hello, World!</code>。这当然不是我们今天关心的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们尝试使用<code>strace</code>命令来查看这个程序，我们会得到大概如下结果。这表明我们的程序使用到了<code>write</code>系统调用。此外，好奇的朋友可以通过<code>man strace</code>命令来查看<code>strace</code>的功能，不必怀疑，这个命令正如说明中表述的那样，可以追踪系统调用和信号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">strace ./01-regualr-print</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到输出：</span></span><br><span class="line"><span class="comment"># execve(&quot;./01-regualr-print&quot;, [&quot;./01-regualr-print&quot;], 0x7ffd3b369be0 /* 39 vars */) = 0</span></span><br><span class="line"><span class="comment"># .......</span></span><br><span class="line"><span class="comment"># write(1, &quot;Hello, World!\n&quot;, 14Hello, World!</span></span><br><span class="line"><span class="comment"># )         = 14</span></span><br><span class="line"><span class="comment"># exit_group(0)                           = ?</span></span><br><span class="line"><span class="comment"># +++ exited with 0 +++</span></span><br></pre></td></tr></table></figure>

<p>那么有没有办法可以直接使用<code>write</code>系统调用呢？答案是肯定的。通过输入命令<code>man syscalls</code>可以了解到，被封装好的系统调用都已经定义在<code>unistd.h</code>这个头文件中。我们仅需要包含这个头文件并且编译就好了。另外，细心的朋友也许注意到了，这个<code>write</code>函数其实和我们平时使用C语言读写文件所用的<code>write</code>函数是同一个函数。这是因为类Unix系统的设计理念是“一切皆文件”，而且<code>write</code>是一个符合POSIX标准的标准C函数。其中，0代表标准输入，1代表标准输出，而2代表标准错误输出。</p>
<p>下面的例子展示了如何通过<code>write</code>来输出Hello World。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> str[] = <span class="string">&quot;Hello,World!\n&quot;</span>;</span><br><span class="line">  write(<span class="number">1</span>, str, <span class="keyword">sizeof</span>(str));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是现在，孔乙己并不满足于这两种系统调用的写法，他还想要学习更多更贴近底层的写法。让我们来使用<code>man syscall</code>了解一下C标准库所提供的直接使用系统调用号来进行系统调用的方法。这份说明中除了讲述了函数的原型、功能和样例，也介绍了不同体系结构下系统调用实现方法的差异。总之先让我们来体验下<code>syscall</code>函数吧。下面的例子中<code>__NR_write</code>是<code>sys_write</code>系统调用的调用号的宏定义，在绝大多数情况下，我想你也可以直接使用数字1来代替。其中NR代表Number，这和我们一般使用的No有所差别。除了这是从Unix传承下来的习惯之外，我想也有避免歧义的考量在里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> str[] = <span class="string">&quot;Hello,World!\n&quot;</span>;</span><br><span class="line">  syscall(__NR_write, <span class="number">1</span>, str, <span class="keyword">sizeof</span>(str));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了这里，其实我们已经了解了大部分系统调用的知识。但是，本着怀疑一切的精神，孔乙己想要挑战下<code>syscall</code>说明的正确性。文档中说到了x86_64架构下<code>syscall</code>是使用哪些寄存器来传递参数的，那么就让我们来验证一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">section .data</span><br><span class="line">    msg db &#x27;Hello,World!&#x27;, 0xa  ; 0xa 是换行符</span><br><span class="line">    len equ $ - msg             ; 计算消息的长度</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ; sys_write 的系统调用号为 1</span><br><span class="line">    mov rax, 1                  ; 将系统调用号 1 (sys_write) 存入 rax 寄存器</span><br><span class="line">    mov rdi, 1                  ; 文件描述符为 1 (stdout)</span><br><span class="line">    mov rsi, msg                ; 将消息的地址存入 rsi 寄存器</span><br><span class="line">    mov rdx, len                ; 将消息的长度存入 rdx 寄存器</span><br><span class="line">    syscall                     ; 调用系统调用</span><br><span class="line">    mov rax, 0</span><br><span class="line"></span><br><span class="line">    ; 退出系统调用的编号为 60，等效于c语言中exit(0)</span><br><span class="line">    mov rax, 60                 ; 将系统调用号 60 (sys_exit) 存入 rax 寄存器</span><br><span class="line">    xor rdi, rdi                ; 将退出码 0 存入 rdi 寄存器</span><br><span class="line">    syscall                     ; 调用系统调用</span><br></pre></td></tr></table></figure>

<p>特别说明，这里我使用了nasm的语法规则，可以使用以下命令来编译。由于我们使用汇编来开发，没有走正常的<code>main</code>作为入口，而是使用elf标准中规定的<code>_start</code>作为程序入口（c语言中的<code>main</code>函数事实上会被编译器生成的<code>_start</code>函数调用）。因此，为了程序可以正常退出，我们还需要额外执行<code>sys_exit</code>系统调用来告诉系统我们的程序正常结束了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf64 -o 04-x86syscall.o 04-x86syscall.S</span><br><span class="line">ld -o 04-x86syscall 04-x86syscall.o</span><br></pre></td></tr></table></figure>

<h2 id="Hacking-in-the-kernel"><a href="#Hacking-in-the-kernel" class="headerlink" title="Hacking in the kernel"></a>Hacking in the kernel</h2><p>现在我们已经了解了Linux的系统调用了，让我们尝试给Linux加入自己设计的系统调用吧！</p>
<p>首先，我们需要打开源代码根目录下<code>./arch/x86/entry/syscalls/syscall_64.tbl</code>这个文件，在最后一行追加我们自己的系统调用，我把它取名为<code>hacing</code>，如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;调用号&gt;  &lt;ABI&gt;   &lt;名字&gt;           &lt;对应函数名&gt;</span></span><br><span class="line">335       common  hacking         __x64_sys_hacking</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后我们需要在<code>./include/linux/syscalls.h</code>中添加我们的函数声明，如下。这时候为了防止错误，最好紧跟你的上一个系统调用添加声明。有时候没有添加对地方可以被放进一个错误的<code>#if</code>预处理宏中间从而导致声明没有被正确添加。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_hacking</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure>

<p>最后，我们需要在<code>./kernel/sys.c</code>文件中实现我们的系统调用了。这一步其实是相对很自由的，你可以在几乎任何地方实现这个函数，只要最后能被正确链接理论上都是可行的。一部分平台相关的系统调用其实放在了<code>./arch/x86</code>目录下，而一些放在了上面说的文件中。你甚至可以自己新建一个文件来实现。但是为了避免一些问题，就让我们随大流编辑<code>./kernel/sys.c</code>吧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(hacking, <span class="type">char</span> __user *, str, <span class="type">size_t</span>, len) &#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">	<span class="keyword">if</span> (len &gt; <span class="number">256</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = copy_from_user(buffer, str, len);</span><br><span class="line">	printk(<span class="string">&quot;Well done, %d. You hacked into the kernel.\n&quot;</span>, buffer);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>SYSCALL_DEFINE2</code>宏帮助我们定义一个带有两个参数的系统调用，名字叫<code>hacking</code>。当然我们完全可以不使用<code>SYSCALL_DEFINE2</code>而是使用我们之前声明的函数原型，这是完全没有错的，不过为了风格统一，这里使用了<code>SYSCALL_DEFINE2</code>宏。<code>__user</code>是一个宏定义，没有任何作用，仅仅作为提示，表示这个地址来自于用户空间，因此需要内核函数<code>copy_from_user</code>将其复制到内核空间再使用。</p>
<p>让我们再次使用<code>make</code>命令来编译内核。与此同时，我们可以开始制作一个用户态的应用程序并且放入根文件系统中，来调用我们自定义的系统调用。请注意，由于busybox不带libc等动态链接库，因此这里需要使用<code>gcc hacking_syscall.c -o hacking_syscall --static</code>来进行静态链接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> str[] = <span class="string">&quot;default man&quot;</span>;</span><br><span class="line">    syscall(<span class="number">335</span>, str, <span class="keyword">sizeof</span>(str));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  syscall(<span class="number">335</span>, argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们将这个程序复制进<code>busybox/__install/bin</code>目录中，再次打包根文件系统并且进入qemu，敲下命令<code>hacking_syscall</code>。我们成功实现了自己的系统调用。</p>
<p><img src="/images/linux-kernel-net-02-01.png"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>strace文档：<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man1/strace.1.html">https://man7.org/linux/man-pages/man1/strace.1.html</a></p>
<p>syscalls文档：<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/syscalls.2.html">https://man7.org/linux/man-pages/man2/syscalls.2.html</a></p>
<p>syscall文档：<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/syscall.2.html">https://man7.org/linux/man-pages/man2/syscall.2.html</a></p>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=https://fishjump.github.io//posts/linux-kernel-net-02/%20余思于斯 - Fism%20从内核出发手撕Linux网络协议栈(二)"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/posts/linux-kernel-net-01/" title="从内核出发手撕Linux网络协议栈(一)"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 从内核出发手撕Linux网络协议栈(一)</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/posts/linux-kernel-net-03/" title="从内核出发手撕Linux网络协议栈(三)">Next post: 从内核出发手撕Linux网络协议栈(三)&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2024&nbsp;<a target="_blank" href="https://fishjump.github.io" rel="noopener noreferrer">Yue Yu</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>