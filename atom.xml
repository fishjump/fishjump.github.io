<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余思于斯 - Fism</title>
  
  
  <link href="https://fishjump.github.io/atom.xml" rel="self"/>
  
  <link href="https://fishjump.github.io/"/>
  <updated>2024-04-20T08:45:29.645Z</updated>
  <id>https://fishjump.github.io/</id>
  
  <author>
    <name>Yue Yu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&quot;I Hacked macOS&quot; Stream Followup</title>
    <link href="https://fishjump.github.io/posts/asahi-linux-hack-collab/"/>
    <id>https://fishjump.github.io/posts/asahi-linux-hack-collab/</id>
    <published>2024-04-20T08:45:29.645Z</published>
    <updated>2024-04-20T08:45:29.645Z</updated>
    
    <content type="html"><![CDATA[<p>Asahi Lina在17号直播了如何使用一个普通用户一键拿到root权限(事实上,这还是她拿到权限的降权)。</p><p><a href="https://www.youtube.com/watch?v=hDek2cp0dmI">直播回放链接</a></p><p>整个直播内容很有启发性，由浅入深的解释了整个过程以及其背后的原理，我相信每个人看完都会有所收获。</p><h3 id="内容大纲"><a href="#内容大纲" class="headerlink" title="内容大纲"></a>内容大纲</h3><ol><li>GPU Basics</li><li>Virtual Memory</li><li>GPU command buffer</li><li>Apple’s secret uPPL</li><li>Return-oriented programming</li></ol><p>要了解整个hack的过程，我们首先需要对GPU这个物理硬件有一定的基础知识，这也会在第一部分讲述。然后，我们需要了解到一些关于虚拟内存的相关内容，绝大多数计算机专业的人应该都清楚这个概念，因此只会提到和hack相关的一些概念而不会全部讲解。接着是GPU command buffer，它用于缓存将要发送给GPU执行的指令的队列。随后我们需要知道uPPL这个Feature的存在，它是一个Apple Silicon私有的CPU特性。传统CPU拥有Ring0-3四个特权级别，0最高而3最低，但是在Apple Silicon中，uPPL是类似于Ring -1级别的存在。最后是一个面向返回值的编程，通过破坏栈结构来构造我们想要的返回值，以及实现任意地址跳转，有相关经验的朋友肯定知道是什么原理，具体内容会在之后解释。</p><p>这个Hack最终可以得到全地址空间的任意读写（chmod 777 &#x2F;dev&#x2F;mem），因此，可以说取得root权限反而是一种“降权”，因为root也讲究尊重页表映射。</p><h2 id="GPU-Basics"><a href="#GPU-Basics" class="headerlink" title="GPU Basics"></a>GPU Basics</h2><p><img src="/images/asahi-linux-hack-collab-cpuvsgpu.png" alt="cpuvsgpu"></p><p>GPU和CPU没有本质上的区别，他们都是一种计算单元，接收输入，然后得到输出。区别在于，GPU可以一次性接收大量的输入，然后并行地进行计算，最后得到大量的输出。此外，GPU内部计算单元更多，但是频率更低，因此，GPU更适合于大量的简单并行计算，而CPU更适合于复杂计算（往往是串行的）。</p><p>在这次的hack当中，读者不需要掌握更多关于GPU并行计算的只是，只要把它当作一个独立于CPU的CPU就好了。</p><h3 id="Apple-GPU-Archtechture"><a href="#Apple-GPU-Archtechture" class="headerlink" title="Apple GPU Archtechture"></a>Apple GPU Archtechture</h3><p><img src="/images/asahi-linux-hack-collab-applegpuarch.png" alt="applegpuarch"></p><p>Apple的GPU如图，内核向coprocessor发送指令，然后coprocessor再将指令发送给GPU硬件。这里的coprocessor是另一个独立于CPU的CPU，但是它也是一个”标准“的CPU（这里是指标准的armv8 cpu），不过性能相对于CPU较低。这样做可以加速CPU和GPU之间的通信，因为这样GPU Firmware不必跑在主CPU上占用资源，而是可以直接在coprocessor上运行。</p><p>对于了解GPU传统使用方法的朋友肯定可以理解VDM和PDM的用处，他们分别负责场景中顶点位置和像素色彩的计算，通常在Shader程序中叫做vertex shader和fragment shader。这里不会详细讲解这两个概念，重点是CDM。因为机器学习的原因流行，General-purpose computing on graphics processing units（GPGPU）的概念越来越普及，CDM就是用于这个目的的，它可以用于通用并行计算，而非仅仅是图形学相关的计算（尽管在其出现之前就有不少人教你如何使用shader来进行科学计算，不过这算一种野路子）。</p><p>此外需要注意的是，这些Data Master仅仅是用于任务调度，指令发送，其真实的计算是由背后的USC来完成的。</p><h2 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">void</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output is &quot;&amp;a is 0x7fffc6ba5ddc&quot;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;a is &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在现代操作系统中，任何程序都是跑在虚拟内存之上的，例如你打印一个变量的内存地址，你会得到一个地址，例如这里是<code>0x7fffc6ba5ddc</code>。地址中每个“1”代表了1 Byte的内存，前面的地址则代表这个变量处于第一百多TB的内存位置，这显然是不可能的，因为通常我们的内存只有几十GB。这就是虚拟内存的作用，它将物理内存映射到虚拟内存。在这里这个物理地址的值是<code>0x814745ddc</code>，大概是内存32GB的空间左右。如果你对如何实现虚拟地址到物理地址感兴趣，你可以研究一下Linux中如何获取页表，通常是和硬件相关的，例如x86的CPU会有一个CR3寄存器，而ARMv8则是TTBR0和TTBR1寄存器，你通常需要在内核态才能访问到这些寄存器。</p><h3 id="虚拟地址到物理地址的映射是如何实现的？"><a href="#虚拟地址到物理地址的映射是如何实现的？" class="headerlink" title="虚拟地址到物理地址的映射是如何实现的？"></a>虚拟地址到物理地址的映射是如何实现的？</h3><p><img src="/images/asahi-linux-hack-collab-addrmapping.png" alt="addrmapping"></p><p>大家可以注意到以上两个地址，<code>0x7fffc6ba5ddc</code>和<code>0x814745ddc</code>，其末尾的<code>0x5ddc</code>是相同的，也就是说，这是一个页内偏移，页大小最大为<code>2^(4*4)=64kb</code>,事实上，Apple使用了16KB的页表，也就是一个64位的地址中，最后14位是页内偏移。<code>0x5ddc</code>的5之所以相同只是因为这两个虚拟地址的页号和物理地址的前缀的最后两位恰好为0而已。</p><p><img src="/images/asahi-linux-hack-collab-addrmapping-1.png" alt="addrmapping-1"></p><p>值得注意的是，每个进程可都有自己的页表，因此不同程序可以拥有相同的虚拟地址而不会导致地址冲突。例如，Cyan和Lina都用有地址<code>0x12345</code>，而他们分别在各自的进程内指向不同的物理地址，这样就不会冲突。同样的原理，Linux内核页拥有自己的页表。事实上，在Linux上有这样一个规则，高地址永远代表内核空间，低地址代表用户空间，如下图所示。</p><p><img src="/images/asahi-linux-hack-collab-highlowaddr.png" alt="highlowaddr"></p><p>将64位地址等分为两部分，高地址部分为内核空间，低地址部分为用户空间。高地址空间的内容由所有进程共享，而低地址空间的内容则由每个进程独立拥有。也就是说，如果你在进程Cyan中修改了某个内核空间的地址，那么进程Lina也会看到这个修改，但是如果你在进程Cyan中修改了某个用户空间的地址，那么进程Lina是看不到这个修改的。</p><p>让我们短暂回到hack这个主题，由于coprocessor也是一个标准的CPU，其也有自己的页表，结构大概如下图所示，其页表结构与主CPU完全相同，因为它们都是标准的CPU。但是权限配置略有不同，因为主CPU需要频繁切换到用户&#x2F;内核态，而协处理器的firmware几乎只工作在内核态，除非渲染的上下文被显式的更换。</p><p><img src="/images/asahi-linux-hack-collab-coprocaddr.png" alt="coprocaddr"></p><h3 id="统一物理内存-（Unified-Memory）"><a href="#统一物理内存-（Unified-Memory）" class="headerlink" title="统一物理内存 （Unified Memory）"></a>统一物理内存 （Unified Memory）</h3><p>这一部分是比较tricky的部分，由于Apple使用了统一物理内存，我们不必通过PCIe来进行CPU&#x2F;GPU数据交换，这可以显著提高性能。但是这也意味着，<strong>我们可以在GPU上直接访问CPU的内存</strong>，这就是这次hack的关键所在。</p><p>让我们先来看一下，在用户态下，这个流程是怎么样的。对于CPU而言，我们需要将一张材质（texture），通常是一张图片，放入内存中。然后创建一个Shader Program，以及我们的用户程序，理所应当的，也是在内存当中。</p><p>然后是对于GPU而言，它并不关心具体的用户程序内容，它只知道获取shader program以及所需的材质。然后，GPU会渲染并输出一张图片，放入内存当中。最后，Screen Controller（屏幕控制器）会将这张图片显示在屏幕上，也就是我们平时在显示器看到的内容。注意最后一步并没有涉及到CPU，屏幕控制器会直接从固定物理地址处读取像素数据，然后显示在屏幕上。</p><p>在整个过程中，shader program和用户空间的程序都是跑在各自对应的页表中的。我们无法直接控制shader program去读取任何物理地址的内容。</p><p><img src="/images/asahi-linux-hack-collab-cpugpuuser.png" alt="cpugpuuser"></p><p>在内核态下，CPU和GPU的交互则是这样的。如下图，CPU在启动阶段会配置其自身的页表以及coprocessor的页表（写入内存中），然后协处理器会将firmware也加载到内存中，不过CPU并不关心firmware的具体内容。当然，Linux内核也会在启动时写入内存，但是GPU同样不关心其具体内容。在GPU工作时，本质上是CPU向内存写入指令，然后协处理器从内存中读取指令，调用GPU功能。在这里，其实是用到了MMIO的概念，也就是Memory Mapped IO，这是一种特殊的IO方式，将IO设备的寄存器映射到内存中，然后通过读写内存来控制IO设备。这里的GPU就是一个IO设备，其寄存器被映射到内存中，然后CPU通过写入内存来控制GPU。除此之外，其上还有其他方式可以控制GPU，例如PCIe，但是苹果并没有使用这种方式。</p><p><img src="/images/asahi-linux-hack-collab-cpugpukernel.png" alt="cpugpukernel"></p><h3 id="页表（Page-Table）"><a href="#页表（Page-Table）" class="headerlink" title="页表（Page Table）"></a>页表（Page Table）</h3><p>现在可以来回顾以下页表的结构，以便我们更好的理解后续的内容。如下图所示，如果使用一个大页表，对于64位的CPU，假设每个表项（一页，16KB）占用8Byte，那么配置1TB大小的虚拟地址（40bit有效位）就需要512MB的页表，这个开销有点大。还记得之前提到过，为了实现进程间的隔离，每个应用都有其单独的页表，因此，如果有100个进程，那么就需要100个页表，也就是50GB的内存，只为了存储页表，这显然是不现实的。</p><p><img src="/images/asahi-linux-hack-collab-onebigtable.png" alt="onebigtable"></p><p>所以，现代CPU普遍使用可配置的多级页表，例如x86的CPU通常配置为三级页表（512B页大小）。Apple Scilicon属于ARMv8架构，Apple配置为三级页表，页大小为16KB。如下图，我们并不需要为所有分支配置真实存在的页表，直到其真正被使用。大多数现代CPU并不完全支持64位地址，如下图，第一级页表使用3位，第二级和第三级均分别占用11位，页大小为16KB，即14位（2^14&#x3D;16KB），总计39位。这是一个已经足够大的空间(512GB)，至少短时间内不会存在不够用的情况。此外，ARMv8在硬件上区分了用户空间和内核空间的地址，如果我们想要访问用户空间的地址，那么我们需要访问TTBR0，如果我们想要访问内核空间的地址，那么我们需要访问TTBR1。</p><p><img src="/images/asahi-linux-hack-collab-treetable.png" alt="treetable"></p><p>以下是一个具体的例子：</p><p><img src="/images/asahi-linux-hack-collab-vmemcvt.png" alt="vmemcvt"></p><p>由于最高位是0，因此访问TTB0寄存器，TTB0寄存器存储了用户态L1 Table的<strong>物理内存地址</strong>，然后接下来3bit为<code>0b001=1</code>，因此访问L1 Table的第1个表项（从0开始计数）。同理类推，直到最后L3 Table记录了前面这写地址所对应的物理地址，然后再拼接上最后14位页内偏移，得到最终的物理地址。注意，这里的地址是40位（1位TTB，39位虚拟地址），而不是64位。在真正的程序中，前面的地址需要和TTB位相同，也就是全0或者全1，否则会引起CPU异常。</p><h3 id="页表权限"><a href="#页表权限" class="headerlink" title="页表权限"></a>页表权限</h3><p><img src="/images/asahi-linux-hack-collab-pageperm.png" alt="pageperm"></p><p>这是一个简化后的例子，每个表项除了有下一级表的物理地址外，还有一些附带的信息来辅助完成一些功能，例如权限控制，页面置换算法等，这里只考虑协处理器和GPU的权限。举个例子，比如对于存有内核信息的页，firmware和GPU都没有访问其的权限，GPU没有访问firmware内容的权限等。</p><p>下面是GPU固件和GPU的内容以及权限的对应关系：</p><p><img src="/images/asahi-linux-hack-collab-gpuperm.png" alt="gpuperm"></p><p>记住GPU Firmware的协处理器和GPU并不是同一个东西，协处理器是一个标准的CPU，而GPU是一个专用的硬件。在协处理器上，固件会改写其页表以将不同的内容写入到不同的GPU Context中。Apple Silicon的GPU支持最多同时加载64个Shader Program，称为Context0到Context63。此外需要注意的是，Context 0是CPU内核独享的，用于GUI渲染等系统高优先级任务，通常我们从Context1开始使用。此外，在GPU上，我们是没有访问GPU固件页表，固件，和Firmware Command的权限的（这一点由GPU上的MMU，也就是内存管理单元来实现）。Firmware Command是一个程序，类似于JVM的存在，是Apple私有的内容。你可以从Kernel Driver发送字节指令给Firmware Command，然后其会执行这些指令。Buffer Control用于控制GPU的缓冲区，例如你可以将一个Shader Program的输出放入缓冲区，称为FBO（Frame Buffer Object），然后当作另一个Shader Program的输入（而不是读取CPU放置的内容），高级的图形驱动也通过Buffer Control来支持局部渲染，提高渲染性能，不过这些信息和今天的主题无关，不再更详细的解释。</p><h3 id="TTBAT（Translation-Table-Base-Address-Table）"><a href="#TTBAT（Translation-Table-Base-Address-Table）" class="headerlink" title="TTBAT（Translation Table Base Address Table）"></a>TTBAT（Translation Table Base Address Table）</h3><p><img src="/images/asahi-linux-hack-collab-ttbat.png" alt="ttbat"></p><p>GPU并没有一个标准的MMU，但是无论如何，它需要一种方式来实现Context切换的功能，也就说，它至少需要知道Context的地址在哪里。这就是TTBAT的作用，它是一个固定的页表，用于存储Context的地址。如上图，各个Context所对应的TTB0地址均不一样，而TTB1均一样。</p><h2 id="开始Hack！！！"><a href="#开始Hack！！！" class="headerlink" title="开始Hack！！！"></a>开始Hack！！！</h2><p>现在你已经掌握了全部的基础知识了，来看看Apple在什么地方犯了错，让我们有机会可以Hack它。</p><p><img src="/images/asahi-linux-hack-collab-memmap.png" alt="memmap"></p><p>Lina在逆向Apple GPU驱动的适合发现了这些页表配置。我们虽然不知道具体哪些比特位代表什么样的权限，但是我们可以知道哪些表项的权限相同，然后我们可以知道哪些功能的权限是如何的。如图，三个红色的权限是相同的，其中一个可能是Read only，一个一定是R&#x2F;w，那么红色的权限就是R&#x2F;W。那么，问题来了，Lina发现了一个不认识的表项，其权限也是R&#x2F;W，经过进一步的分析，这个表项是Firmware Command Buffer所在的地址空间，理论上它不应该可以被GPU访问。</p><h3 id="Firmware-Command-Buffer"><a href="#Firmware-Command-Buffer" class="headerlink" title="Firmware Command Buffer"></a>Firmware Command Buffer</h3><p><img src="/images/asahi-linux-hack-collab-cmdbuffer.png" alt="cmdbuffer"></p><p>我们可以通过运行在CPU上的GPU驱动向协处理器发送上面这样一个格式的调用，其中microsequence就是上面提到的，Firmware Command可以像JVM一样解释执行的字节码。按理来说，这样的字节码功能是有限的，但是Apple可能是为了方便调试的原因，把所有的功能都放在了这里，导致这个字节码是图灵完备的，也就是说，我们可以在这里实现任何功能。比如我们可以通过load&#x2F;store指令来读写内存，通过test指令来比较大小（if控制流），通过add来实现计算（例如逻辑运算，比如异或和加法来实现减法，通过加法和循环来实现乘法），通过jump指令来执行有条件&#x2F;无条件跳转。这样，我们就可以实现任何功能了。</p><p><img src="/images/asahi-linux-hack-collab-isa.png" alt="isa"></p><p>总结一下，这个破解思路是，首先CPU向协处理器发送字节码，然后协处理器将字节码写入到Firmware Command Buffer，然后Firmware Command解释执行这些字节码。到此为止，我们还没有任何权限，但是，由于Firmware Command会调用GPU去执行我们的shader program，此时，我们是控制GPU的，而恰好GPU上的页表配置错误，导致我们可以访问Firmware Command Buffer。在Shader程序执行结束后，协处理器会从协处理器的栈上读取返回地址从而返回到上一层Firmware Command中的函数，但是此时这个栈上的内容已经被我们修改了，因此，我们可以实现任意地址跳转。整个过程的修改是在GPU上完成的，但是最终我们取得的是协处理器的虚拟机权限。具体如何操作，我们会在之后的内容中讲解。</p><p>是到此为止，我们还只拥有Firmware Command的读写权限，而不是全部内存的读写权限。我们需要进一步的提升权限。</p><h3 id="Self-Modifying-Code"><a href="#Self-Modifying-Code" class="headerlink" title="Self-Modifying Code"></a>Self-Modifying Code</h3><p><img src="/images/asahi-linux-hack-collab-smc.png" alt="smc"></p><p>现在思考一下，由于microsequence的执行内容是固定的，唯一的变数就是microsequence会调用我们写的shader程序，那么我们能不能在shader程序中实现任意功能呢？答案是肯定的。由于冯诺以曼结构，程序的数据和程序本身都是在内存中。例如，一段shader程序将一个地址写入到xxx地址，而xxx的地址就是下一条指令的地址，这样就等于我修改了这个程序自身，从而可以实现任意地址跳转，最后将程序跳转到我们想要执行的firmware command中的指令序列。通常来说，程序所在的内存是只读的，但是这里由于Apple的失误，我们可以自由的在运行时修改程序的内容。</p><h3 id="uPPL"><a href="#uPPL" class="headerlink" title="uPPL"></a>uPPL</h3><p>到此为止，我们只能修改Firmware Command Buffer的内容，其实这本身没有太大意义，我们只能很有限的修改协处理器的行为，但是我们无法修改CPU的行为。</p><p>但是，我们可以利用uPPL的一个漏洞！</p><p><img src="/images/asahi-linux-hack-collab-uPPL.png" alt="uPPL"></p><p>也许有细心的人可以意识到，uPPL是CPU的一个部分，适用于主CPU和协处理器。如果你打算在协处理器上访问uPPL的配置，uPPL本身，或者其他页表或内核数据的数据，那么这些请求都会被uPPL拒绝。注意，这是虽然说uPPL有全部页表的访问权限，但是只是它自己有权限，如果外部请求访问这些敏感内容，它有权利拒绝（如果配置正确的话）。</p><p>但是访问TTBAT（也就是GPU的页表）呢？它不阻止你在协处理器上读写TTBAT，似乎苹果写协处理器部分的程序员没有意识到GPU上的问题，因此只配置了CPU部分的权限！</p><p>也许还有人要问，那么是否可以在GPU上直接修改TTBAT呢？答案是不可以，因为GPU上的MMU会阻止你这么做。</p><h3 id="Hack流程"><a href="#Hack流程" class="headerlink" title="Hack流程"></a>Hack流程</h3><p>现在已经可以得到一个大致的流程了：</p><ol><li>通过我们的shader程序，修改Firmware Command Buffer中的内容，获取Firmware Command的控制权限</li><li>通过coprocessor，修改GPU的页表，获取GPU的控制权限</li><li>将任意地址映射写入GPU的页表，假装其是一个Context</li><li>再次调用shader程序，修改假Context的内容，实现任意地址读写</li><li>修改firmware command这个虚拟机本身的内容，实现执行任意汇编指令（之前只能执行虚拟机中的字节码）</li><li>自然而然的，我们可以拿到root shell了</li></ol><h3 id="Return-Oriented-Programming"><a href="#Return-Oriented-Programming" class="headerlink" title="Return-Oriented Programming"></a>Return-Oriented Programming</h3><p><img src="/images/asahi-linux-hack-collab-rop.png" alt="rop"></p><p>要拿到虚拟机和协处理器的控制权限，我们需要知道一个函数是如何返回的。尽管两者在细节上略有不同，但是本质是一样的。</p><p>如上图，x86架构下函数的返回地址会在栈上。而ARMv8架构下，对于单层函数调用，会有一个Link Register（LR）来存储返回地址。而对于多层函数调用，会先将现有的LR压入栈中，然后将新的LR写入到LR寄存器中。总之，我们只需要修改当前的栈内容，就可以控制函数的返回地址了。</p><h3 id="Root-Shell获取"><a href="#Root-Shell获取" class="headerlink" title="Root Shell获取"></a>Root Shell获取</h3><p>Lina没有在直播中在这里多做讲解，大概原理就是，扫描macOS内核中的特定内容（因为内核代码中一定存在magic number），找到这个特定内容之后，由于我们可以很容易的在内核态执行代码来获取内核函数以及内核头的虚拟地址等信息，我们可以通过这个特定内容计算出内核头的物理地址，然后我们再找到获取root权限的函数，通过ROP的方式调用这个函数，就可以拿到root权限了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Asahi Lina在17号直播了如何使用一个普通用户一键拿到root权限(事实上,这还是她拿到权限的降权)。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=hDek2cp0dmI&quot;&gt;直播回放链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;整个</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>从内核出发手撕Linux网络协议栈(一)</title>
    <link href="https://fishjump.github.io/posts/linux-kernel-net-01/"/>
    <id>https://fishjump.github.io/posts/linux-kernel-net-01/</id>
    <published>2024-04-20T08:45:29.645Z</published>
    <updated>2024-04-20T08:45:29.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><p>接触Linux也几年时间了，翻过不少相关博客和书籍，尝试过啃一些Linux内核源代码，但总觉得少了点什么。琢磨来琢磨去，渐渐有了个想法：或许是缺少了理论与实践的结合。书上的知识虽珍贵，实践却是另一回事。曾经写过不少代码，读过不少书，但书归书，实践归实践。于是，我决定要开始真正动手，去改动Linux内核源代码，试着用自己的思路替换或改进其中的网络协议栈。这个计划，我暂且命名为“忒修斯的船”。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>现在这个计划的第一步就是从源码开始编译出一个可以运行的Linux系统。为此，这里需要知道一些基本的知识。Linux内核本身仅提供了对硬件的抽象和管理，它包含了操作系统的核心功能，比如进程管理、内存管理、文件系统等。Linux内核提供了系统调用接口，使用户空间程序可以与硬件进行交互，并且提供了一系列的API供用户空间程序调用，以便进行系统操作。而Linux发行版通常还包含了其他用户空间的程序和工具，例如系统库、Shell、命令行工具、图形界面环境等。</p><p>这篇文章将采用Linux 4.19内核，这是<a href="http://kernel.org/">Kernel.org</a>上最古老且长期受支持的版本。选择这个老版本的内核是因为新版本引入了许多复杂的新功能和优化，这些对新手来说可能有些难以理解，并且可能会让读者分心，不利于形成自己的内核源码阅读方法论，尤其是对于内核的大体框架和设计思路。获取内核后，我们将使用busybox构建我们的根文件系统，即Linux系统中的Shell和命令行工具等。最后，我们将使用qemu启动我们自己的“Linux发行版”。</p><h2 id="编译Linux源码"><a href="#编译Linux源码" class="headerlink" title="编译Linux源码"></a>编译Linux源码</h2><p>读者可以在<a href="http://kernel.org/">Kernel.org</a>上自行下载并解压，或者使用下面的命令下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.19.311.tar.gz</span><br><span class="line">tar -xvf linux-4.19.311.tar.gz</span><br></pre></td></tr></table></figure><p>本例中使用的是x86环境，如果想要编译到其他环境，按需要可能需要交叉编译器。如果是Apple Silicon Mac用户，那么就需要指定目标架构是arm。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=x86</span><br></pre></td></tr></table></figure><p>然后我们需要配置我们的内核，为了避免一个一个设置带来的繁琐操作，可以先生成一个默认的配置然后再进行微调。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接保存退出</span></span><br><span class="line">make x86_64_defconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启Gneral setup --&gt; Initial RAM filesystem and RAM disk (initramfs/initrd) support</span></span><br><span class="line"><span class="comment"># 开启Device Drivers --&gt; Block Devices --&gt; RAM block device support</span></span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译Linux内核，可能需要安装一些软件，读者根据提示和自己的发行版来安装。</span></span><br><span class="line"><span class="comment"># 编译输出为arch/x86_64/boot/bzImage</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>我们之所以启用这些设置，主要是因为我希望能够在内存中展开我们的rootfs，而不是实际挂载一个硬盘。当然，我们可以创建一个虚拟硬盘文件，将rootfs写入其中，并将其指定给qemu，但这样做太过繁琐。目前，我们的关注重点并不在这些事情上，而是从源代码中构建一个可以启动的Linux系统。</p><h2 id="编译Busybox"><a href="#编译Busybox" class="headerlink" title="编译Busybox"></a>编译Busybox</h2><p>在我们着手编译Busybox之前，首先需要获取其源代码并进行编译。尽管我们并不深入研究Busybox的源码，但值得注意的是，Busybox并不直接影响内核的运行。因此，在理论上，我们可以选择任何版本的Busybox进行编译。在这次的操作中，我选择了最新版本的Busybox源码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.busybox.net/downloads/busybox-1.36.1.tar.bz2</span><br><span class="line">tar -xvf busybox-1.36.1.tar.bz2</span><br></pre></td></tr></table></figure><p>由于Busybox的主要目的是提供一个精简的Unix工具集，因此它并不编译任何动态链接库。在完成下载和解压后，我们需要配置Busybox的编译选项，将其设置为静态链接，这样它就不会依赖于任何动态库。否则，如果将Busybox放入我们的根文件系统并启动我们自己的Linux，可能会因缺少依赖而导致运行失败。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启Busybox Settings --&gt; Build Options --&gt; Build BusyBox as a static binary (no shared libs)</span></span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译输出为busybox源码目录下的_install目录</span></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>除了编译Busybox，我们还需要额外创建一些文件和目录，具体如下所示。其中，部分命令需要以sudo或者root权限执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> etc dev mnt proc sys tmp</span><br><span class="line"><span class="built_in">mkdir</span> etc/init.d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内容设置为:</span></span><br><span class="line"><span class="comment"># proc        /proc           proc         defaults        0        0</span></span><br><span class="line"><span class="comment"># tmpfs       /tmp            tmpfs    　　defaults        0        0</span></span><br><span class="line"><span class="comment"># sysfs       /sys            sysfs        defaults        0        0</span></span><br><span class="line">vim etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内容设置为:</span></span><br><span class="line"><span class="comment"># echo -e &quot;Welcome to tinyLinux&quot;</span></span><br><span class="line"><span class="comment"># /bin/mount -a</span></span><br><span class="line"><span class="comment"># echo -e &quot;Remounting the root filesystem&quot;</span></span><br><span class="line"><span class="comment"># mount  -o  remount,rw  /</span></span><br><span class="line"><span class="comment"># mkdir -p /dev/pts</span></span><br><span class="line"><span class="comment"># mount -t devpts devpts /dev/pts</span></span><br><span class="line"><span class="comment"># echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</span></span><br><span class="line"><span class="comment"># mdev -s</span></span><br><span class="line">vim etc/init.d/rcS</span><br><span class="line"><span class="built_in">chmod</span> 755 etc/init.d/rcS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内容设置为:</span></span><br><span class="line"><span class="comment"># ::sysinit:/etc/init.d/rcS</span></span><br><span class="line"><span class="comment"># ::respawn:-/bin/sh</span></span><br><span class="line"><span class="comment"># ::askfirst:-/bin/sh</span></span><br><span class="line">vim etc/inittab</span><br><span class="line"><span class="built_in">chmod</span> 755 etc/inittab</span><br></pre></td></tr></table></figure><p>在Linux系统中，fstab是一个至关重要的配置文件，它承担着文件系统挂载的责任。当内核将rootfs原封不动地复制到内存中，并将执行权限交给init进程后，大多数的init进程会依据fstab来挂载其他文件系统。正如我们在上面创建的<code>etc/init.d/rcS</code>脚本中所使用的那样，通过执行<code>mount -a</code>命令来根据fstab挂载文件系统。然而，如今的许多发行版已经开始采用systemd来管理这些API文件系统，如proc、tmp、sys等。因此，在我们正在使用的Linux系统中可能无法在fstab中找到这些条目。</p><p><code>rcS</code>是我们在inittab中配置的启动脚本，它定义了系统在启动后所执行的任务。而inittab则是init进程的一些设置，在每个发行版中可能略有不同。对于Busybox的配置，你可以参考<a href="https://git.busybox.net/busybox/tree/examples/inittab">busybox官方示例</a>。此外，我们需要确保这两个文件具有可执行权限，使用<code>chmod 755</code>命令来赋予它们权限。</p><h2 id="启动操作系统"><a href="#启动操作系统" class="headerlink" title="启动操作系统"></a>启动操作系统</h2><p>接下来，我们只需将我们的根文件目录打包起来，并使用qemu来启动它即可。在这里，我们选择了ext3分区格式，但读者也可以选择其他支持的格式，比如fat32。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=./rootfs.ext3 bs=1M count=32</span><br><span class="line">mkfs.ext3 rootfs.ext3</span><br><span class="line"><span class="built_in">mkdir</span> fs</span><br><span class="line">mount -o loop rootfs.ext3 ./fs</span><br><span class="line"><span class="built_in">cp</span> -rf ./busybox-1.36.1/_install/* ./fs</span><br><span class="line">umount ./fs</span><br><span class="line">gzip --best -c rootfs.ext3 &gt; rootfs.img.gz</span><br></pre></td></tr></table></figure><p>在格式化一个块文件将其变成ext3格式,挂载并将<code>_install</code>目录的内容复制进去,取消挂载,并将其压缩之后.我们可以用qemu启动我们的Linux了. 注意启动参数, 我们将<code>root=/dev/ram init=/linuxrc</code>作为参数传递给内核, 其意味着我们将使用内存来作为我们的根文件系统, 即所有”文件操作”都是在内存中而不是真正的在修改我们的硬盘. 此外init进程的程序为<code>/linuxrc</code>,我们可以在<code>_install</code>目录找到它.</p><p>首先，我们需要对一个块文件进行格式化，使其成为ext3格式。然后，我们将挂载这个格式化后的块文件，并将<code>_install</code>目录中的内容复制到其中。接着，我们取消对挂载文件系统的挂载。接下来，我们将对块文件进行压缩，以便后续使用qemu启动。在启动时，我们需要特别注意启动参数。通过传递<code>root=/dev/ram init=/linuxrc</code>给内核，我们告诉系统将内存作为根文件系统，使得所有的文件操作都将在内存中进行，而不会对硬盘进行实质性的修改。同时，我们指定了init进程的程序为<code>/linuxrc</code>，这个程序可以在<code>_install</code>目录中找到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -kernel ./linux-4.19.311/arch/x86_64/boot/bzImage  \</span><br><span class="line">  -initrd ./rootfs.img.gz   \</span><br><span class="line">  -append <span class="string">&quot;root=/dev/ram init=/linuxrc&quot;</span>  \</span><br><span class="line">  -serial file:output.txt</span><br></pre></td></tr></table></figure><p><img src="/images/linux-kernel-net-01-01.png"></p><p>当系统成功启动后，我们将在qemu中验证我之前的一些说法。首先，我们执行<code>df -a</code>命令，通过观察文件系统的挂载情况来验证。结果显示，文件系统确实如fstab中所示被正确地挂载了。此外，我们还注意到<code>/dev/root</code>被挂载在了根目录<code>/</code>上，这也与我们的预期相符。</p><p><img src="/images/linux-kernel-net-01-02.png"></p><p>现在让我们使用<code>ls -al /dev | less</code>来看看<code>/dev/root</code>和<code>/dev/ram</code>的关系。如下图，可以看见<code>/dev/root</code>是指向<code>/dev/ram9</code>的一个软链接。</p><p><img src="/images/linux-kernel-net-01-03.png"></p><p>最后,让我们确认下我们的init进程，使用<code>ps -a | less</code>命令，可以看见1号进程确实是linuxrc这个程序。</p><p><img src="/images/linux-kernel-net-01-04.png"></p><p>到此，我们已成功启动了我们自己的Linux系统。在接下来的文章中，我将尝试修改系统中的代码，以定制一个属于我们自己的特别版Linux。通过这个过程，我们将深入学习Linux系统的网络协议栈。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>fstab配置格式: <a href="https://wiki.archlinux.org/title/Fstab">https://wiki.archlinux.org/title/Fstab</a></p><p>API文件系统: <a href="https://www.freedesktop.org/wiki/Software/systemd/APIFileSystems/">https://www.freedesktop.org/wiki/Software/systemd/APIFileSystems/</a></p><p>inittab配置格式: <a href="https://git.busybox.net/busybox/tree/examples/inittab">https://git.busybox.net/busybox/tree/examples/inittab</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;随笔&quot;&gt;&lt;a href=&quot;#随笔&quot; class=&quot;headerlink&quot; title=&quot;随笔&quot;&gt;&lt;/a&gt;随笔&lt;/h2&gt;&lt;p&gt;接触Linux也几年时间了，翻过不少相关博客和书籍，尝试过啃一些Linux内核源代码，但总觉得少了点什么。琢磨来琢磨去，渐渐有了个想法：或许</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>从内核出发手撕Linux网络协议栈(二)</title>
    <link href="https://fishjump.github.io/posts/linux-kernel-net-02/"/>
    <id>https://fishjump.github.io/posts/linux-kernel-net-02/</id>
    <published>2024-04-20T08:45:29.645Z</published>
    <updated>2024-04-20T08:45:29.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="孔乙己-系统调用的调用有四种写法"><a href="#孔乙己-系统调用的调用有四种写法" class="headerlink" title="孔乙己: 系统调用的调用有四种写法"></a>孔乙己: 系统调用的调用有四种写法</h2><p>既然这个系列是从源码开始手撕Linux网络协议栈，那么不妨先了解一下Linux的系统调用是如何发生的，然后尝试自己给Linux添加一个系统调用，以便之后更容易了解和学习网络模块的内核实现。</p><p>以一个简单的例子开始，以下是一个常规的Hello World。尝试编译这个程序并运行会毫不意外的看到控制台输出了<code>Hello, World!</code>。这当然不是我们今天关心的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们尝试使用<code>strace</code>命令来查看这个程序，我们会得到大概如下结果。这表明我们的程序使用到了<code>write</code>系统调用。此外，好奇的朋友可以通过<code>man strace</code>命令来查看<code>strace</code>的功能，不必怀疑，这个命令正如说明中表述的那样，可以追踪系统调用和信号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">strace ./01-regualr-print</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到输出：</span></span><br><span class="line"><span class="comment"># execve(&quot;./01-regualr-print&quot;, [&quot;./01-regualr-print&quot;], 0x7ffd3b369be0 /* 39 vars */) = 0</span></span><br><span class="line"><span class="comment"># .......</span></span><br><span class="line"><span class="comment"># write(1, &quot;Hello, World!\n&quot;, 14Hello, World!</span></span><br><span class="line"><span class="comment"># )         = 14</span></span><br><span class="line"><span class="comment"># exit_group(0)                           = ?</span></span><br><span class="line"><span class="comment"># +++ exited with 0 +++</span></span><br></pre></td></tr></table></figure><p>那么有没有办法可以直接使用<code>write</code>系统调用呢？答案是肯定的。通过输入命令<code>man syscalls</code>可以了解到，被封装好的系统调用都已经定义在<code>unistd.h</code>这个头文件中。我们仅需要包含这个头文件并且编译就好了。另外，细心的朋友也许注意到了，这个<code>write</code>函数其实和我们平时使用C语言读写文件所用的<code>write</code>函数是同一个函数。这是因为类Unix系统的设计理念是“一切皆文件”，而且<code>write</code>是一个符合POSIX标准的标准C函数。其中，0代表标准输入，1代表标准输出，而2代表标准错误输出。</p><p>下面的例子展示了如何通过<code>write</code>来输出Hello World。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> str[] = <span class="string">&quot;Hello,World!\n&quot;</span>;</span><br><span class="line">  write(<span class="number">1</span>, str, <span class="keyword">sizeof</span>(str));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是现在，孔乙己并不满足于这两种系统调用的写法，他还想要学习更多更贴近底层的写法。让我们来使用<code>man syscall</code>了解一下C标准库所提供的直接使用系统调用号来进行系统调用的方法。这份说明中除了讲述了函数的原型、功能和样例，也介绍了不同体系结构下系统调用实现方法的差异。总之先让我们来体验下<code>syscall</code>函数吧。下面的例子中<code>__NR_write</code>是<code>sys_write</code>系统调用的调用号的宏定义，在绝大多数情况下，我想你也可以直接使用数字1来代替。其中NR代表Number，这和我们一般使用的No有所差别。除了这是从Unix传承下来的习惯之外，我想也有避免歧义的考量在里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> str[] = <span class="string">&quot;Hello,World!\n&quot;</span>;</span><br><span class="line">  syscall(__NR_write, <span class="number">1</span>, str, <span class="keyword">sizeof</span>(str));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里，其实我们已经了解了大部分系统调用的知识。但是，本着怀疑一切的精神，孔乙己想要挑战下<code>syscall</code>说明的正确性。文档中说到了x86_64架构下<code>syscall</code>是使用哪些寄存器来传递参数的，那么就让我们来验证一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">section .data</span><br><span class="line">    msg db &#x27;Hello,World!&#x27;, 0xa  ; 0xa 是换行符</span><br><span class="line">    len equ $ - msg             ; 计算消息的长度</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ; sys_write 的系统调用号为 1</span><br><span class="line">    mov rax, 1                  ; 将系统调用号 1 (sys_write) 存入 rax 寄存器</span><br><span class="line">    mov rdi, 1                  ; 文件描述符为 1 (stdout)</span><br><span class="line">    mov rsi, msg                ; 将消息的地址存入 rsi 寄存器</span><br><span class="line">    mov rdx, len                ; 将消息的长度存入 rdx 寄存器</span><br><span class="line">    syscall                     ; 调用系统调用</span><br><span class="line">    mov rax, 0</span><br><span class="line"></span><br><span class="line">    ; 退出系统调用的编号为 60，等效于c语言中exit(0)</span><br><span class="line">    mov rax, 60                 ; 将系统调用号 60 (sys_exit) 存入 rax 寄存器</span><br><span class="line">    xor rdi, rdi                ; 将退出码 0 存入 rdi 寄存器</span><br><span class="line">    syscall                     ; 调用系统调用</span><br></pre></td></tr></table></figure><p>特别说明，这里我使用了nasm的语法规则，可以使用以下命令来编译。由于我们使用汇编来开发，没有走正常的<code>main</code>作为入口，而是使用elf标准中规定的<code>_start</code>作为程序入口（c语言中的<code>main</code>函数事实上会被编译器生成的<code>_start</code>函数调用）。因此，为了程序可以正常退出，我们还需要额外执行<code>sys_exit</code>系统调用来告诉系统我们的程序正常结束了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf64 -o 04-x86syscall.o 04-x86syscall.S</span><br><span class="line">ld -o 04-x86syscall 04-x86syscall.o</span><br></pre></td></tr></table></figure><h2 id="Hacking-in-the-kernel"><a href="#Hacking-in-the-kernel" class="headerlink" title="Hacking in the kernel"></a>Hacking in the kernel</h2><p>现在我们已经了解了Linux的系统调用了，让我们尝试给Linux加入自己设计的系统调用吧！</p><p>首先，我们需要打开源代码根目录下<code>./arch/x86/entry/syscalls/syscall_64.tbl</code>这个文件，在最后一行追加我们自己的系统调用，我把它取名为<code>hacing</code>，如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;调用号&gt;  &lt;ABI&gt;   &lt;名字&gt;           &lt;对应函数名&gt;</span></span><br><span class="line">335       common  hacking         __x64_sys_hacking</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们需要在<code>./include/linux/syscalls.h</code>中添加我们的函数声明，如下。这时候为了防止错误，最好紧跟你的上一个系统调用添加声明。有时候没有添加对地方可以被放进一个错误的<code>#if</code>预处理宏中间从而导致声明没有被正确添加。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_hacking</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure><p>最后，我们需要在<code>./kernel/sys.c</code>文件中实现我们的系统调用了。这一步其实是相对很自由的，你可以在几乎任何地方实现这个函数，只要最后能被正确链接理论上都是可行的。一部分平台相关的系统调用其实放在了<code>./arch/x86</code>目录下，而一些放在了上面说的文件中。你甚至可以自己新建一个文件来实现。但是为了避免一些问题，就让我们随大流编辑<code>./kernel/sys.c</code>吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(hacking, <span class="type">char</span> __user *, str, <span class="type">size_t</span>, len) &#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">256</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = copy_from_user(buffer, str, len);</span><br><span class="line">printk(<span class="string">&quot;Well done, %d. You hacked into the kernel.\n&quot;</span>, buffer);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>SYSCALL_DEFINE2</code>宏帮助我们定义一个带有两个参数的系统调用，名字叫<code>hacking</code>。当然我们完全可以不使用<code>SYSCALL_DEFINE2</code>而是使用我们之前声明的函数原型，这是完全没有错的，不过为了风格统一，这里使用了<code>SYSCALL_DEFINE2</code>宏。<code>__user</code>是一个宏定义，没有任何作用，仅仅作为提示，表示这个地址来自于用户空间，因此需要内核函数<code>copy_from_user</code>将其复制到内核空间再使用。</p><p>让我们再次使用<code>make</code>命令来编译内核。与此同时，我们可以开始制作一个用户态的应用程序并且放入根文件系统中，来调用我们自定义的系统调用。请注意，由于busybox不带libc等动态链接库，因此这里需要使用<code>gcc hacking_syscall.c -o hacking_syscall --static</code>来进行静态链接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> str[] = <span class="string">&quot;default man&quot;</span>;</span><br><span class="line">    syscall(<span class="number">335</span>, str, <span class="keyword">sizeof</span>(str));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  syscall(<span class="number">335</span>, argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们将这个程序复制进<code>busybox/__install/bin</code>目录中，再次打包根文件系统并且进入qemu，敲下命令<code>hacking_syscall</code>。我们成功实现了自己的系统调用。</p><p><img src="/images/linux-kernel-net-02-01.png"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>strace文档：<a href="https://man7.org/linux/man-pages/man1/strace.1.html">https://man7.org/linux/man-pages/man1/strace.1.html</a></p><p>syscalls文档：<a href="https://man7.org/linux/man-pages/man2/syscalls.2.html">https://man7.org/linux/man-pages/man2/syscalls.2.html</a></p><p>syscall文档：<a href="https://man7.org/linux/man-pages/man2/syscall.2.html">https://man7.org/linux/man-pages/man2/syscall.2.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;孔乙己-系统调用的调用有四种写法&quot;&gt;&lt;a href=&quot;#孔乙己-系统调用的调用有四种写法&quot; class=&quot;headerlink&quot; title=&quot;孔乙己: 系统调用的调用有四种写法&quot;&gt;&lt;/a&gt;孔乙己: 系统调用的调用有四种写法&lt;/h2&gt;&lt;p&gt;既然这个系列是从源码开始</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>从内核出发手撕Linux网络协议栈(三)</title>
    <link href="https://fishjump.github.io/posts/linux-kernel-net-03/"/>
    <id>https://fishjump.github.io/posts/linux-kernel-net-03/</id>
    <published>2024-04-20T08:45:29.645Z</published>
    <updated>2024-04-20T08:45:29.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h2><p>上一回说到一个系统调用是如何实现的，这次就从系统调用的定义开始拆解<code>socket</code>系统调用的源码。正所谓工欲善其事，必先利其器，由于C语言本身的特性，导致IDE跳转的功能并不总是好用。这里有两种解决方案，一种是使用<code>ctags</code>命令来生成符号文件供IDE使用，IDE大概率也内置了这样的功能。这个功能的缺点是，由于Linux源码中为了兼容多种体系，有很多重复的函数定义在不同的体系目录下。而第二种方法更为现代，即利用<code>compile_commands.json</code>这个文件来帮助我们查看真实编译时使用的编译指令。</p><p>对于高版本内核，其内部已经集成了对<code>compile_commands.json</code>的支持。我们只需要使用<code>make compile_commands.json</code>即可生成对应的文件，然后在vscode或者其他你喜欢的编辑器或者ide中配置对应的选项即可。现代的工具大概率已经集成了对这项特性的支持。但是，我们使用的4.19版本内核源码还没有提供这样的支持。此时我们可以使用到<code>bear</code>命令来hook make的过程，这个命令可以在Github找到下载地址，并且大概率大多数Linux发行版已经提供对其的支持，直接使用自己的包管理工具下载即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line"><span class="comment"># 会在工作目录生成compile_commands.json</span></span><br><span class="line">bear make</span><br></pre></td></tr></table></figure><h2 id="socket系统调用"><a href="#socket系统调用" class="headerlink" title="socket系统调用"></a>socket系统调用</h2><p>想要研究清楚<code>socket</code>系统调用，那么首先肯定还是要知道<code>socket</code>函数是如何被使用的。我们将如下例子的参数带入到后面的讲解中。我们通常使用如下的方法来创建一个TCP连接的socket。对于不熟悉C语言网络API的朋友来说，可能好奇为什么这当中为什么没有指定端口号。这是因为我们需要在之后使用<code>bind</code>函数来指定端口，当然这是后面的话题了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上面例子中的三个分别是<code>family</code>（或者有些地方称之为<code>domain</code>），<code>type</code>和<code>protocol</code>。其中<code>family</code>指的是协议族，常见的有<code>AF_INET</code>和<code>AF_INET6</code>，即IPv4和IPv6。第二个参数叫做<code>type</code>，即<code>socket</code>连接的类型，Linux中定义的且常用的有<code>SOCK_STREAM</code>和<code>SOCK_DGRAM</code>，通常来说对应了TCP和UDP协议。但是它们本质上是指选择一套有连接或者无连接的协议（数据报协议）。第三个参数<code>protocol</code>则代表了通信协议。这里是一个特殊情况，当你决定了<code>type</code>参数之后将<code>protocol</code>设置为<code>0</code>，那么即默认选择TCP或者UDP。你当然也可以显式指明<code>IPPROTO_TCP</code>或<code>IPPROTO_UDP</code>。这里需要注意一点，<code>type</code>和<code>protocol</code>是不能自由排列组合的，例如指定<code>type</code>为<code>SOCKET_STREAM</code>且指定<code>protocol</code>为<code>IPPROTO_UDP</code>是非法的。</p><h2 id="从系统调用入口开始"><a href="#从系统调用入口开始" class="headerlink" title="从系统调用入口开始"></a>从系统调用入口开始</h2><p>按照上一集的介绍，我们知道了<code>socket</code>是拥有三个参数的系统调用，那么我们可以搜索<code>&quot;SYSCALL_DEFINE3(socket&quot;</code>来找到<code>socket</code>定义的位置，它在<code>net/socket.c</code>中，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;SYSCALL_DEFINE3\(socket&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(socket, <span class="type">int</span>, family, <span class="type">int</span>, type, <span class="type">int</span>, protocol)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __sys_socket(family, type, protocol);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它原样传递给了一个内部实现，这个内部实现的源码可以通过IDE内的跳转功能轻易找到（如果你正确配置了<code>compile_commands.json</code>）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __sys_socket(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check the SOCK_* constants for consistency.  */</span></span><br><span class="line">BUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);</span><br><span class="line">BUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);</span><br><span class="line">BUILD_BUG_ON(SOCK_CLOEXEC &amp; SOCK_TYPE_MASK);</span><br><span class="line">BUILD_BUG_ON(SOCK_NONBLOCK &amp; SOCK_TYPE_MASK);</span><br><span class="line"></span><br><span class="line">flags = type &amp; ~SOCK_TYPE_MASK;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~(SOCK_CLOEXEC | SOCK_NONBLOCK))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">type &amp;= SOCK_TYPE_MASK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SOCK_NONBLOCK != O_NONBLOCK &amp;&amp; (flags &amp; SOCK_NONBLOCK))</span><br><span class="line">flags = (flags &amp; ~SOCK_NONBLOCK) | O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">retval = sock_create(family, type, protocol, &amp;sock);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sock_map_fd(sock, flags &amp; (O_CLOEXEC | O_NONBLOCK));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除开一些配置，我们可以看见<code>socket</code>主要做了两件事。第一，通过<code>sock_create</code>函数来创建一个socket；第二，将这个sock使用<code>sock_map_fd</code>映射到文件系统中，因为UNIX的设计思路是一切皆文件。</p><h2 id="sock-create函数解析"><a href="#sock-create函数解析" class="headerlink" title="sock_create函数解析"></a>sock_create函数解析</h2><p>跳转到<code>sock_create</code>函数，它同样经过了一层包装。这层包装主要是在系统层面实现网络代理功能，并且区分用户态和内核态建立起的连接（即通过socket函数只能创建用户态socket连接）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sock_create</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol, <span class="keyword">struct</span> socket **res)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __sock_create(current-&gt;nsproxy-&gt;net_ns, family, type, protocol, res, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入真正的内部实现，值得关注的点主要有两个函数调用。其一，<code>sock_alloc</code>创建了一个<code>struct socket</code>对象；其二，函数内调用了<code>pf-&gt;create</code>来创建（或者说真正初始化<code>struct socket</code>对象）。在讲解上面两点之前可以大致梳理一下其他函数。整个函数的前半段主要是一些防呆错误判断。中间有出现security开头的函数，主要是实现安全方面的内容。读者可以通过全局搜索，找到两处这个函数的定义，一处在<code>include/linux/security.h</code>，以内联空函数的形式出现，而另一处在<code>security/security.c</code>，具有真正的功能。并且我们可以在头文件中观察到函数实现的选择是通过定义<code>CONFIG_SECURITY_NETWORK</code>来实现的。它可以在<code>make menuconfig</code>或者<code>.config</code>文件中配置。这里我们可以暂时跳过它。另一处则是rcu系列的函数，可以通过它们的名字和询问Google，ChatGPT得知。这些函数主要是实现锁的功能，我们这里也暂时不关心它们。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __sock_create(<span class="keyword">struct</span> net *net, <span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol,</span><br><span class="line"> <span class="keyword">struct</span> socket **res, <span class="type">int</span> kern)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> *<span class="title">pf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      Check protocol is in range</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (family &lt; <span class="number">0</span> || family &gt;= NPROTO)</span><br><span class="line"><span class="keyword">return</span> -EAFNOSUPPORT;</span><br><span class="line"><span class="keyword">if</span> (type &lt; <span class="number">0</span> || type &gt;= SOCK_MAX)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compatibility.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This uglymoron is moved from INET layer to here to avoid</span></span><br><span class="line"><span class="comment">   deadlock in module load.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (family == PF_INET &amp;&amp; type == SOCK_PACKET) &#123;</span><br><span class="line">pr_info_once(<span class="string">&quot;%s uses obsolete (PF_INET,SOCK_PACKET)\n&quot;</span>,</span><br><span class="line">     current-&gt;comm);</span><br><span class="line">family = PF_PACKET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = security_socket_create(family, type, protocol, kern);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Allocate the socket and allow the family to set things up. if</span></span><br><span class="line"><span class="comment"> *the protocol is 0, the family is instructed to select an appropriate</span></span><br><span class="line"><span class="comment"> *default.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sock = sock_alloc();</span><br><span class="line"><span class="keyword">if</span> (!sock) &#123;</span><br><span class="line">net_warn_ratelimited(<span class="string">&quot;socket: no more sockets\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -ENFILE;<span class="comment">/* Not exactly a match, but its the</span></span><br><span class="line"><span class="comment">   closest posix thing */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sock-&gt;type = type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line"><span class="comment">/* Attempt to load a protocol module if the find failed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user</span></span><br><span class="line"><span class="comment"> * requested real, full-featured networking support upon configuration.</span></span><br><span class="line"><span class="comment"> * Otherwise module support will break!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (rcu_access_pointer(net_families[family]) == <span class="literal">NULL</span>)</span><br><span class="line">request_module(<span class="string">&quot;net-pf-%d&quot;</span>, family);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">pf = rcu_dereference(net_families[family]);</span><br><span class="line">err = -EAFNOSUPPORT;</span><br><span class="line"><span class="keyword">if</span> (!pf)</span><br><span class="line"><span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We will call the -&gt;create function, that possibly is in a loadable</span></span><br><span class="line"><span class="comment"> * module, so we have to bump that loadable module refcnt first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!try_module_get(pf-&gt;owner))</span><br><span class="line"><span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now protected by module ref count */</span></span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">err = pf-&gt;create(net, sock, protocol, kern);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_module_put;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now to bump the refcnt of the [loadable] module that owns this</span></span><br><span class="line"><span class="comment"> * socket at sock_release time we decrement its refcnt.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!try_module_get(sock-&gt;ops-&gt;owner))</span><br><span class="line"><span class="keyword">goto</span> out_module_busy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now that we&#x27;re done with the -&gt;create function, the [loadable]</span></span><br><span class="line"><span class="comment"> * module can have its refcnt decremented</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">module_put(pf-&gt;owner);</span><br><span class="line">err = security_socket_post_create(sock, family, type, protocol, kern);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out_sock_release;</span><br><span class="line">*res = sock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_module_busy:</span><br><span class="line">err = -EAFNOSUPPORT;</span><br><span class="line">out_module_put:</span><br><span class="line">sock-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">module_put(pf-&gt;owner);</span><br><span class="line">out_sock_release:</span><br><span class="line">sock_release(sock);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">out_release:</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">goto</span> out_sock_release;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sock-alloc函数解析"><a href="#sock-alloc函数解析" class="headerlink" title="sock_alloc函数解析"></a>sock_alloc函数解析</h3><p>显然让我们进入<code>sock_alloc</code>函数来看看。这个函数很简单，如下所示。值得关注的点主要在<code>new_inode_pseudo</code>和<code>SOCKET_I</code>上。其中<code>new_inode_pseudo</code>创建了一个inode，然后<code>SOCKET_I</code>将这个inode和一个socket指针联系在了一起。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> socket *<span class="title function_">sock_alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">inode = new_inode_pseudo(sock_mnt-&gt;mnt_sb);</span><br><span class="line"><span class="keyword">if</span> (!inode)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">sock = SOCKET_I(inode);</span><br><span class="line"></span><br><span class="line">inode-&gt;i_ino = get_next_ino();</span><br><span class="line">inode-&gt;i_mode = S_IFSOCK | S_IRWXUGO;</span><br><span class="line">inode-&gt;i_uid = current_fsuid();</span><br><span class="line">inode-&gt;i_gid = current_fsgid();</span><br><span class="line">inode-&gt;i_op = &amp;sockfs_inode_ops;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>new_inode_pseudo</code>，通过观察函数的名字，参数名字以及按F12跳转，我们可以知道：</p><ol><li>这是文件系统相关的操作，<code>sock_mnt</code>大概率是代表一个文件系统上的挂载点</li><li>这个函数大概率是在<code>sock_mnt</code>这个挂载点上创建一个pseudo inode，即伪inode。也就是并不真实存在于硬盘上，但是存在于文件系统中的inode。这也表现出了UNIX一切皆文件的特点。</li></ol><p>口说无凭，虽然这里我们不关心文件系统的部分，但是我们可以查看<code>sock_mnt</code>的定义。很明显它是一个全局变量，因为它没有在这个函数内定义。通过跳转和全局搜索，我么可以查看到<code>sock_mnt</code>的使用情况。可以看见它就是一个vfsmount，即virtual filesystem mount，虚拟文件系统挂载点。并且在<code>sock_init</code>函数中很明确调用了文件系统和挂载相关的函数，并且赋值给它。到此，我们不打算进一步深究，否则就有点脱离今天的主题，网络协议栈了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sock_mnt的定义</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">sock_mnt</span> __<span class="title">read_mostly</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">sock_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// .... 其他函数调用</span></span><br><span class="line">err = register_filesystem(&amp;sock_fs_type);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out_fs;</span><br><span class="line">sock_mnt = kern_mount(&amp;sock_fs_type);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(sock_mnt)) &#123;</span><br><span class="line">err = PTR_ERR(sock_mnt);</span><br><span class="line"><span class="keyword">goto</span> out_mount;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// .... 其他函数调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一个我们感兴趣的东西是<code>SOCKET_I</code>，它的定义同样可以通过跳转来找到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_alloc</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> <span class="title">socket</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">vfs_inode</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> socket *<span class="title function_">SOCKET_I</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;container_of(inode, <span class="keyword">struct</span> socket_alloc, vfs_inode)-&gt;socket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了<code>container_of</code>，它是一个Linux内核代码中常用的宏定义，具体的实现代码有点复杂，但是原理还是比较简单的。首先，Linux使用了C语言编写，而C语言并不支持C++中的模板特性。因此，当我们使用一个数据结构时（例如链表，二叉树等结构），我们没有办法如STL那样将我们的对象“装入”到数据结构中。相反，如下所示，我们需要在对象中添加一个数据结构的字段。其中的<code>list</code>指向下一个Duck的<code>list</code>字段。但是这时我们是无法直接访问Duck的其他元素的，因为我们持有的仅仅是一个<code>struct list_head</code>对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Duck</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">  <span class="type">char</span> duck_name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了解决这个问题，我们有两种办法。第一，我们可以约定<code>struct list_head</code>必须是结构体的第一个元素，如下面的例子，那么list的地址也一定是Duck的地址。但是这样的方法缺少一定的灵活性。第二个方法更为泛用，首先我们有一个list的，并且我明确知道它是被套在一个Duck对象里面，那么list到Duck对象的首地址的偏移一定是确定的（即C语言中结构体中的元素在编译期一定是确定的）。这时候，我们可以通过这样的一个技巧来计算出这个偏移量：将一个<code>NULL</code>指针强转成Duck类型，然后使其指向list，即<code>&amp;((Duck*)NULL)-&gt;list</code>。这样我们就得到一个list的偏移值，因为<code>NULL</code>被定义为0。当然，为了保险起见，我们可以再减去<code>NULL</code>来确保我们的结果正确。</p><p>这里就可以再插入一个知识点。可能会有人认为这样的操作可能会引起异常，因为我们在访问一个非法的地址。但是事实上这样的操作是安全的，因为我们并没有去尝试读取list的内容，而只是对其使用<code>&amp;</code>取地址操作。</p><p>回到<code>SOCKET_I</code>函数，这里其实的作用就是：我现在持有一个<code>inode</code>，并且我明确知道这个<code>inode</code>存在于<code>struct socket_alloc</code>结构体中，并且<code>inode</code>的字段是<code>vfs_inode</code>。那么<code>container_of</code>宏会告诉我这个<code>struct socket_alloc</code>对象的地址是多少。</p><p>到了这里，我们明白了<code>sock_alloc</code>整个函数的功能。但是还有一点也许读者并没有注意到，那就是在<code>sock_alloc</code>函数中，<code>inode</code>和<code>sock</code>都是在函数内创建的变量，似乎并没有涉及到<code>struct socket_alloc</code>这个结构体。为了解决这个疑点，我们可以同样全局搜索<code>struct socket_alloc</code>，发现还有<code>sock_alloc_inode</code>，<code>sock_destroy_inode</code>等函数用到了它。这样似乎就可以解决我们的疑问了，即在创建inode的过程中，即<code>new_inode_pseudo</code>中，我们确保了<code>inode</code>和<code>sock</code>存在一一对应的关系。</p><p>我们可以继续搜索<code>sock_alloc_inode</code>，发现它被放置于<code>sockfs_ops</code>中，为一组函数指针。而<code>sockfs_ops</code>则在<code>sockfs_mount</code>被传递给文件系统。按照同样的方法向上搜索，可以追溯到上面讨论过的<code>sock_init</code>函数中。即这些操作都是网络模块向文件系统注册过的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">sockfs_ops</span> =</span> &#123;</span><br><span class="line">.alloc_inode= sock_alloc_inode,</span><br><span class="line">.destroy_inode= sock_destroy_inode,</span><br><span class="line">.statfs= simple_statfs,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">sockfs_mount</span><span class="params">(<span class="keyword">struct</span> file_system_type *fs_type,</span></span><br><span class="line"><span class="params"> <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *dev_name, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mount_pseudo_xattr(fs_type, <span class="string">&quot;socket:&quot;</span>, &amp;sockfs_ops,</span><br><span class="line">  sockfs_xattr_handlers,</span><br><span class="line">  &amp;sockfs_dentry_operations, SOCKFS_MAGIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pf-create到底是个啥"><a href="#pf-create到底是个啥" class="headerlink" title="pf-&gt;create到底是个啥"></a>pf-&gt;create到底是个啥</h3><p>到此我们可以进入到<code>sock_create</code>的下一个函数，<code>pf-&gt;create</code>函数。通过上面的例子，我们也可以知道在Linux内核源码中，函数指针是很常用的。这里同样是一个函数指针的调用，为了查清楚这个指针究竟来自哪里，我们有两种思路。这里两种方法都可以达到我们的目的。但是有时候一种方法不行，或者可能选项太多的时候，可以尝试换另一种方法。</p><ol><li>查看pf的类型和定义，并搜索这个类型的使用情况。</li><li>查看pf的赋值情况，并且查看数据源或者函数。</li></ol><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>通过搜索pf的类型<code>struct net_proto_family</code>，我们可以找到一系列文件。这里推荐使用<code>rg</code>命令（ripgreg，一个更快的<code>grep</code>命令）或者vscode内建的搜索来完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rg <span class="string">&quot;struct net_proto_family&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中有一项结果为</span></span><br><span class="line"><span class="comment"># net/ipv4/af_inet.c</span></span><br><span class="line"><span class="comment"># 1075:static const struct net_proto_family inet_family_ops = &#123;</span></span><br></pre></td></tr></table></figure><p>在众多结果中，有一项看起来很可能是我们感兴趣的内容。因为它的文件名是<code>net/ipv4/af_inet.c</code>。</p><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>我们可以在<code>__sock_create</code>函数内找到这一行语句<code>pf = rcu_dereference(net_families[family]);</code>。并且我们已经知道rcu本身是锁相关的代码，因此我们可以直接查看<code>net_families</code>的定义和赋值情况。</p><p>再次通过搜索，我们看到一个可能感兴趣的点，<code>rcu_assign_pointer(net_families[ops-&gt;family], ops)</code>，这条语句出现在<code>sock_register</code>函数中，更加能说明这很可能能追溯到<code>pf-&gt;create</code>从哪里来。尝试全局搜索<code>sock_register</code>，我们能得到和思路一一样的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rg sock_register</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中有一项结果为</span></span><br><span class="line"><span class="comment"># net/ipv4/af_inet.c</span></span><br><span class="line"><span class="comment"># 1915:   (void)sock_register(&amp;inet_family_ops);</span></span><br></pre></td></tr></table></figure><h4 id="探索af-inet和socket的联系"><a href="#探索af-inet和socket的联系" class="headerlink" title="探索af_inet和socket的联系"></a>探索af_inet和socket的联系</h4><p>无论是通过上面哪种方法，我们都能知道我们可以在<code>inet_family_ops</code>这个对象中找到<code>create</code>的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> =</span> &#123;</span><br><span class="line">.family = PF_INET,</span><br><span class="line">.create = inet_create,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">inet_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 其他代码。。。</span></span><br><span class="line">    (<span class="type">void</span>)sock_register(&amp;inet_family_ops);</span><br><span class="line">    <span class="comment">// 其他代码。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们阅读<code>inet_create</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">inet_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> socket *sock, <span class="type">int</span> protocol,</span></span><br><span class="line"><span class="params">       <span class="type">int</span> kern)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> *<span class="title">answer_prot</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> answer_flags;</span><br><span class="line"><span class="type">int</span> try_loading_module = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (protocol &lt; <span class="number">0</span> || protocol &gt;= IPPROTO_MAX)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">sock-&gt;state = SS_UNCONNECTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Look for the requested type/protocol pair. */</span></span><br><span class="line">lookup_protocol:</span><br><span class="line">err = -ESOCKTNOSUPPORT;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="built_in">list</span>) &#123;</span><br><span class="line"></span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* Check the non-wild match. */</span></span><br><span class="line"><span class="keyword">if</span> (protocol == answer-&gt;protocol) &#123;</span><br><span class="line"><span class="keyword">if</span> (protocol != IPPROTO_IP)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Check for the two wild cases. */</span></span><br><span class="line"><span class="keyword">if</span> (IPPROTO_IP == protocol) &#123;</span><br><span class="line">protocol = answer-&gt;protocol;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = -EPROTONOSUPPORT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(err)) &#123;</span><br><span class="line"><span class="keyword">if</span> (try_loading_module &lt; <span class="number">2</span>) &#123;</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Be more specific, e.g. net-pf-2-proto-132-type-1</span></span><br><span class="line"><span class="comment"> * (net-pf-PF_INET-proto-IPPROTO_SCTP-type-SOCK_STREAM)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (++try_loading_module == <span class="number">1</span>)</span><br><span class="line">request_module(<span class="string">&quot;net-pf-%d-proto-%d-type-%d&quot;</span>,</span><br><span class="line">       PF_INET, protocol, sock-&gt;type);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Fall back to generic, e.g. net-pf-2-proto-132</span></span><br><span class="line"><span class="comment"> * (net-pf-PF_INET-proto-IPPROTO_SCTP)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">request_module(<span class="string">&quot;net-pf-%d-proto-%d&quot;</span>,</span><br><span class="line">       PF_INET, protocol);</span><br><span class="line"><span class="keyword">goto</span> lookup_protocol;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">goto</span> out_rcu_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -EPERM;</span><br><span class="line"><span class="keyword">if</span> (sock-&gt;type == SOCK_RAW &amp;&amp; !kern &amp;&amp;</span><br><span class="line">    !ns_capable(net-&gt;user_ns, CAP_NET_RAW))</span><br><span class="line"><span class="keyword">goto</span> out_rcu_unlock;</span><br><span class="line"></span><br><span class="line">sock-&gt;ops = answer-&gt;ops;</span><br><span class="line">answer_prot = answer-&gt;prot;</span><br><span class="line">answer_flags = answer-&gt;flags;</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">WARN_ON(!answer_prot-&gt;slab);</span><br><span class="line"></span><br><span class="line">err = -ENOBUFS;</span><br><span class="line">sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot, kern);</span><br><span class="line"><span class="keyword">if</span> (!sk)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (INET_PROTOSW_REUSE &amp; answer_flags)</span><br><span class="line">sk-&gt;sk_reuse = SK_CAN_REUSE;</span><br><span class="line"></span><br><span class="line">inet = inet_sk(sk);</span><br><span class="line">inet-&gt;is_icsk = (INET_PROTOSW_ICSK &amp; answer_flags) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">inet-&gt;nodefrag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SOCK_RAW == sock-&gt;type) &#123;</span><br><span class="line">inet-&gt;inet_num = protocol;</span><br><span class="line"><span class="keyword">if</span> (IPPROTO_RAW == protocol)</span><br><span class="line">inet-&gt;hdrincl = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (net-&gt;ipv4.sysctl_ip_no_pmtu_disc)</span><br><span class="line">inet-&gt;pmtudisc = IP_PMTUDISC_DONT;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">inet-&gt;pmtudisc = IP_PMTUDISC_WANT;</span><br><span class="line"></span><br><span class="line">inet-&gt;inet_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sock_init_data(sock, sk);</span><br><span class="line"></span><br><span class="line">sk-&gt;sk_destruct   = inet_sock_destruct;</span><br><span class="line">sk-&gt;sk_protocol   = protocol;</span><br><span class="line">sk-&gt;sk_backlog_rcv = sk-&gt;sk_prot-&gt;backlog_rcv;</span><br><span class="line"></span><br><span class="line">inet-&gt;uc_ttl= <span class="number">-1</span>;</span><br><span class="line">inet-&gt;mc_loop= <span class="number">1</span>;</span><br><span class="line">inet-&gt;mc_ttl= <span class="number">1</span>;</span><br><span class="line">inet-&gt;mc_all= <span class="number">1</span>;</span><br><span class="line">inet-&gt;mc_index= <span class="number">0</span>;</span><br><span class="line">inet-&gt;mc_list= <span class="literal">NULL</span>;</span><br><span class="line">inet-&gt;rcv_tos= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sk_refcnt_debug_inc(sk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (inet-&gt;inet_num) &#123;</span><br><span class="line"><span class="comment">/* It assumes that any protocol which allows</span></span><br><span class="line"><span class="comment"> * the user to assign a number at socket</span></span><br><span class="line"><span class="comment"> * creation time automatically</span></span><br><span class="line"><span class="comment"> * shares.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">inet-&gt;inet_sport = htons(inet-&gt;inet_num);</span><br><span class="line"><span class="comment">/* Add to protocol hash chains. */</span></span><br><span class="line">err = sk-&gt;sk_prot-&gt;hash(sk);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">sk_common_release(sk);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_prot-&gt;init) &#123;</span><br><span class="line">err = sk-&gt;sk_prot-&gt;init(sk);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">sk_common_release(sk);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!kern) &#123;</span><br><span class="line">err = BPF_CGROUP_RUN_PROG_INET_SOCK(sk);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">sk_common_release(sk);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">out_rcu_unlock:</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这一段函数中，除去一些锁操作，错误校验和单纯枯燥的赋值之外。值得关注的点就是。</p><ol><li><code>list_for_each_entry_rcu</code>这个循环</li><li><code>sock-&gt;ops = answer-&gt;ops</code>赋值，我们想知道有哪些操作被传递给了<code>sock</code></li><li><code>sock_init_data(sock, sk)</code>函数调用，<code>socket</code>和<code>sock</code>结构体的差别是什么</li></ol><p>首先，让我们看看<code>list_for_each_entry_rcu</code>这个循环。尝试搜索就可以发现它是一个宏定义，并且本质上就是<code>for</code>循环和<code>container_of</code>的组合。我们之前已经聊过<code>container_of</code>了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_entry_rcu(ptr, type, member) \</span></span><br><span class="line"><span class="meta">container_of(READ_ONCE(ptr), type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_entry_rcu(pos, head, member) \</span></span><br><span class="line"><span class="meta">for (pos = list_entry_rcu((head)-&gt;next, typeof(*pos), member); \</span></span><br><span class="line"><span class="meta">&amp;pos-&gt;member != (head); \</span></span><br><span class="line"><span class="meta">pos = list_entry_rcu(pos-&gt;member.next, typeof(*pos), member))</span></span><br></pre></td></tr></table></figure><p>通过搜索可以知道，inetsw是一个链表数组<code>static struct list_head inetsw[SOCK_MAX]</code>，并且我们可以合理地猜测每个链表是按照<code>sock</code>的<code>type</code>分开的，即有连接（<code>SOCK_STREAM</code>），无连接（<code>SOCK_DGRAM</code>）以及其他类型。例如，在<code>inetsw[SOCK_STREAM]</code>上应当会有TCP协议的实现所对应的对象，而<code>inetsw[SOCK_DGRAM]</code>链表上可以找到UDP的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="built_in">list</span>) &#123;</span><br><span class="line"></span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* Check the non-wild match. */</span></span><br><span class="line"><span class="keyword">if</span> (protocol == answer-&gt;protocol) &#123;</span><br><span class="line"><span class="keyword">if</span> (protocol != IPPROTO_IP)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Check for the two wild cases. */</span></span><br><span class="line"><span class="keyword">if</span> (IPPROTO_IP == protocol) &#123;</span><br><span class="line">protocol = answer-&gt;protocol;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = -EPROTONOSUPPORT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们暂且不去寻找这些实现，且关注这个循环本身。第一个if很好理解，当<code>if (protocol == answer-&gt;protocol) &#123; if (protocol != IPPROTO_IP) break; &#125;</code>，找到对应的协议时，且它不是一个通用协议的时候（<code>IPPROTO_IP</code>在约定中是一个wild protocol，即通配协议）。我们退出循环，并且带着<code>answer</code>（因为它在函数一开始就创建了，不会因为离开作用域而销毁）进入到下面的步骤。</p><p>而后面的else个人认为不太直观。当第一次循环开始且链表上第一个元素不等于我们要找的元素时，如果<code>protocol</code>等于<code>IPPROTO_IP</code>，即0（可以通过查找宏定义得知），那么就让<code>protocol</code>等于当前的<code>answer</code>并退出循环（因为判断中<code>if (IPPROTO_IP == protocol)</code>的<code>protocol</code>和<code>IPPROTO_IP</code>均不会随循环改变，如果第一次匹配不上那么就永远匹配不上了）。其实这也就是说，<code>SOCK_STREAM</code>链表上第一个元素一定是TCP协议的实现，这也就是为什么最开始的例子里面，我们可以使用<code>sockfd = socket(AF_INET, SOCK_STREAM, 0)</code>来创建TCP连接，而不必指定<code>IPPROTO_TCP</code>，UDP也是同理。</p><p>第二个判断，当<code>if (IPPROTO_IP == answer-&gt;protocol)</code>，我们也跳出循环。说明这个类型的链表上有一个协议注册为了通用协议，不论我们要找的是什么协议都会返回它（正常情况它会被注册为链表最后一个元素）。默认情况下，只用使用<code>type=SOCK_RAW</code>才会用到它，即我们想基于裸IP协议进行一些操作时才会用到它，而不使用任何协议，如TCP，UDP等。</p><p>如果所有条件均不满足，那么就会得到<code>err = -EPROTONOSUPPORT</code>，返回错误。</p><p>现在来看第二个点，<code>sock-&gt;ops = answer-&gt;ops</code>。那么我们可以通过之前的方案，已知<code>answer</code>来自于<code>inetsw</code>。那么追溯<code>inetsw</code>可以看到它是一个<code>list_head</code>数组，并且在<code>inet_register_protosw</code>中被赋值。继续追溯，可以查到<code>inet_init</code>中调用了<code>inet_register_protosw</code>函数，且所有数据来自于<code>inetsw_array</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">inetsw</span>[<span class="title">SOCK_MAX</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inet_register_protosw</span><span class="params">(<span class="keyword">struct</span> inet_protosw *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 其他代码。。。</span></span><br><span class="line">last_perm = &amp;inetsw[p-&gt;type];</span><br><span class="line">list_for_each(lh, &amp;inetsw[p-&gt;type]) &#123;</span><br><span class="line">answer = list_entry(lh, <span class="keyword">struct</span> inet_protosw, <span class="built_in">list</span>);</span><br><span class="line"><span class="comment">/* Check only the non-wild match. */</span></span><br><span class="line"><span class="keyword">if</span> ((INET_PROTOSW_PERMANENT &amp; answer-&gt;flags) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (protocol == answer-&gt;protocol)</span><br><span class="line"><span class="keyword">goto</span> out_permanent;</span><br><span class="line">last_perm = lh;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 其他代码。。。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">inet_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 其他代码。。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register the socket-side information for inet_create. */</span></span><br><span class="line"><span class="keyword">for</span> (r = &amp;inetsw[<span class="number">0</span>]; r &lt; &amp;inetsw[SOCK_MAX]; ++r)</span><br><span class="line">INIT_LIST_HEAD(r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)</span><br><span class="line">inet_register_protosw(q);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他代码。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们尝试搜索<code>inetsw_array</code>时，所有东西都有了答案。我们可以看见Linux内核默认支持的所有IP族协议了。并且通过跳转<code>tcp_prot</code>等变量，可以看见各个协议的具体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] =</span></span><br><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line">.type =       SOCK_STREAM,</span><br><span class="line">.protocol =   IPPROTO_TCP,</span><br><span class="line">.prot =       &amp;tcp_prot,</span><br><span class="line">.ops =        &amp;inet_stream_ops,</span><br><span class="line">.flags =      INET_PROTOSW_PERMANENT |</span><br><span class="line">      INET_PROTOSW_ICSK,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">.type =       SOCK_DGRAM,</span><br><span class="line">.protocol =   IPPROTO_UDP,</span><br><span class="line">.prot =       &amp;udp_prot,</span><br><span class="line">.ops =        &amp;inet_dgram_ops,</span><br><span class="line">.flags =      INET_PROTOSW_PERMANENT,</span><br><span class="line">       &#125;,</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">.type =       SOCK_DGRAM,</span><br><span class="line">.protocol =   IPPROTO_ICMP,</span><br><span class="line">.prot =       &amp;ping_prot,</span><br><span class="line">.ops =        &amp;inet_sockraw_ops,</span><br><span class="line">.flags =      INET_PROTOSW_REUSE,</span><br><span class="line">       &#125;,</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">       .type =       SOCK_RAW,</span><br><span class="line">       .protocol =   IPPROTO_IP,<span class="comment">/* wild card */</span></span><br><span class="line">       .prot =       &amp;raw_prot,</span><br><span class="line">       .ops =        &amp;inet_sockraw_ops,</span><br><span class="line">       .flags =      INET_PROTOSW_REUSE,</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>让我们之后再来深挖tcp协议的具体实现。先回到刚刚的主题，还有第三个问题没有解决，那就是<code>struct socket</code>结构体和<code>struct sock</code>结构体的关系。通过跳转到<code>struct socket</code>结构体的定义，我们可以看见<code>struct sock sk</code>是<code>struct socket</code>结构体内部的一个元素，并且进入<code>struct sock</code>结构体的定义（太长此处不展开），可以看见许多内部底层的内容，通过搜索引擎可以知道，<code>struct sock</code>中的内容主要是供内核使用，而<code>struct socket</code>是暴露给用户态的接口。此处详细内容就不再深究，因为我们现在主要关心的是<code>struct socket</code>创建的整个主流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">socket_statestate;</span><br><span class="line"></span><br><span class="line"><span class="type">short</span>type;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_wq</span>*<span class="title">wq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span>*<span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span>*<span class="title">sk</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span>*<span class="title">ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="sock-create函数总结"><a href="#sock-create函数总结" class="headerlink" title="sock_create函数总结"></a>sock_create函数总结</h3><p>到此，我们已经挖完了<code>sock_create</code>函数的主流程。它会先创建一个<code>inode</code>给<code>sock</code>，并且根据对应入参的协议族选择对应的<code>create</code>函数来初始化这个<code>sock</code>。接下来我们会研究<code>sock_map_fd</code>。顾名思义，它会将我们的<code>socket</code>映射到一个具体的文件上，并且返回文件描述符<code>fd</code>（file descriptor）。</p><h2 id="sock-map-fd函数解析"><a href="#sock-map-fd函数解析" class="headerlink" title="sock_map_fd函数解析"></a>sock_map_fd函数解析</h2><p>由于我们在<code>sock_create</code>函数中已经拥有了一个<code>inode</code>，这一块的主要任务，可以合理地猜想，就是将我们的<code>inode</code>映射到一个具体的文件上面，并且获得一个文件描述符。</p><p>进入函数，我们可以看到主流程很简单。首先是<code>get_unused_fd_flags</code>获取一个未使用的<code>fd</code>号。这里其实可以衍生出一个很有趣的，关于文件系统的面试题。那就是当服务器<code>fd</code>耗尽有什么办法解决。解决办法很多，我们可以提高<code>fd</code>的上限（是的，这是可以配置的）；或者是优化资源使用，少创建<code>fd</code>；对<code>fd</code>复用，而不是一个客户端一个<code>fd</code>，例如<code>epoll</code>等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sock_map_fd</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">newfile</span>;</span></span><br><span class="line"><span class="type">int</span> fd = get_unused_fd_flags(flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(fd &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">sock_release(sock);</span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newfile = sock_alloc_file(sock, flags, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (likely(!IS_ERR(newfile))) &#123;</span><br><span class="line">fd_install(fd, newfile);</span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">put_unused_fd(fd);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(newfile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步，我们可以进入<code>sock_alloc_file</code>查看<code>sock</code>是如何和一个文件联系起来的。类似于<code>socket_create</code>，这里我们创建了一个pseudo file，并且将一些<code>socket</code>操作抽象成了文件操作，放在了<code>socket_file_ops</code>中传递给文件系统，例如<code>open</code>，<code>close</code>，<code>write</code>等操作，这使得我们的文件系统知道如何操作这些文件。</p><p>可以看到这里使用了<code>SOCK_INODE</code>函数来获取<code>sock</code>对应的<code>inode</code>。如果跳转过去，可以发现它就在之前的<code>SOCKET_I</code>函数旁边，使用同样的原理完成了<code>socket</code>和<code>inode</code>的双向互查。如果创建成功，那么我们在<code>sock</code>和<code>file</code>中加入互相的指针以实现互查，然后返回<code>file</code>指针。</p><p>最后是<code>fd_install</code>函数，可以进入这个函数发现它是一个文件系统内的函数，因此今天也不做深究。它的大概功能可以通过名字和搜索引擎知道，就是绑定文件描述符和文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> file *<span class="title function_">sock_alloc_file</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *dname)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dname)</span><br><span class="line">dname = sock-&gt;sk ? sock-&gt;sk-&gt;sk_prot_creator-&gt;name : <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">file = alloc_file_pseudo(SOCK_INODE(sock), sock_mnt, dname,</span><br><span class="line">O_RDWR | (flags &amp; O_NONBLOCK),</span><br><span class="line">&amp;socket_file_ops);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">sock_release(sock);</span><br><span class="line"><span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sock-&gt;file = file;</span><br><span class="line">file-&gt;private_data = sock;</span><br><span class="line"><span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sock-map-fd总结"><a href="#sock-map-fd总结" class="headerlink" title="sock_map_fd总结"></a>sock_map_fd总结</h3><p>这个函数相比<code>sock_create</code>要简单不少。当然以上都是纯粹的代码分析。这里做一个实验。大家可以尝试随便启动一个tcp或者http服务器（毕竟基于TCP，不讨论HTTP3的特例的话），然后找到它的进程编号。那么大概率你可以在文件系统中看见类似于下面的内容，这也证明socket确实是被当作一个文件在操作，和我们阅读代码中的内容一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到你的进程编号</span></span><br><span class="line">ps -aux | grep main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索这个进程下的文件描述符 </span></span><br><span class="line">ll /proc/&lt;pid&gt;/fd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到类似的输出</span></span><br><span class="line"><span class="comment"># total 0</span></span><br><span class="line"><span class="comment"># dr-x------ 2 &lt;uid&gt; &lt;uid&gt;  0 Apr 13 21:38 .</span></span><br><span class="line"><span class="comment"># dr-xr-xr-x 9 &lt;uid&gt; &lt;uid&gt;  0 Apr 13 21:38 ..</span></span><br><span class="line"><span class="comment"># lrwx------ 1 &lt;uid&gt; &lt;uid&gt; 64 Apr 13 21:38 0 -&gt; /dev/pts/15</span></span><br><span class="line"><span class="comment"># lrwx------ 1 &lt;uid&gt; &lt;uid&gt; 64 Apr 13 21:38 1 -&gt; /dev/pts/15</span></span><br><span class="line"><span class="comment"># lr-x------ 1 &lt;uid&gt; &lt;uid&gt; 64 Apr 13 21:38 19 -&gt; /dev/urandom</span></span><br><span class="line"><span class="comment"># lrwx------ 1 &lt;uid&gt; &lt;uid&gt; 64 Apr 13 21:38 2 -&gt; /dev/pts/15</span></span><br><span class="line"><span class="comment"># l-wx------ 1 &lt;uid&gt; &lt;uid&gt; 64 Apr 13 21:38 20 -&gt; /home/&lt;uid&gt;/.vscode-server/data/logs/20240413T101955/ptyhost.log</span></span><br><span class="line"><span class="comment"># l-wx------ 1 &lt;uid&gt; &lt;uid&gt; 64 Apr 13 21:38 21 -&gt; /home/&lt;uid&gt;/.vscode-server/data/logs/20240413T101955/remoteagent.log</span></span><br><span class="line"><span class="comment"># lrwx------ 1 &lt;uid&gt; &lt;uid&gt; 64 Apr 13 21:38 22 -&gt; /dev/ptmx</span></span><br><span class="line"><span class="comment"># lrwx------ 1 &lt;uid&gt; &lt;uid&gt; 64 Apr 13 21:38 23 -&gt; /dev/ptmx</span></span><br><span class="line"><span class="comment"># l-wx------ 1 &lt;uid&gt; &lt;uid&gt; 64 Apr 13 21:38 25 -&gt; /home/&lt;uid&gt;/.vscode-server/data/logs/20240413T101955/network.log</span></span><br><span class="line"><span class="comment"># lrwx------ 1 &lt;uid&gt; &lt;uid&gt; 64 Apr 13 21:38 3 -&gt; &#x27;socket:[21472904]&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>inet_create分支解析：<a href="https://github.com/xgfone/snippet/blob/master/snippet/docs/linux/program/raw-socket-demystified.txt">https://github.com/xgfone/snippet/blob/master/snippet/docs/linux/program/raw-socket-demystified.txt</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;事前准备&quot;&gt;&lt;a href=&quot;#事前准备&quot; class=&quot;headerlink&quot; title=&quot;事前准备&quot;&gt;&lt;/a&gt;事前准备&lt;/h2&gt;&lt;p&gt;上一回说到一个系统调用是如何实现的，这次就从系统调用的定义开始拆解&lt;code&gt;socket&lt;/code&gt;系统调用的源码。正所</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>从内核出发手撕Linux网络协议栈(四)</title>
    <link href="https://fishjump.github.io/posts/linux-kernel-net-04/"/>
    <id>https://fishjump.github.io/posts/linux-kernel-net-04/</id>
    <published>2024-04-20T08:45:29.645Z</published>
    <updated>2024-04-20T08:45:29.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bind系统调用的定义"><a href="#Bind系统调用的定义" class="headerlink" title="Bind系统调用的定义"></a>Bind系统调用的定义</h2><p>在上一集，我们讨论了<code>socket</code>系统调用的实现，并且介绍了一些关于阅读Linux内核代码的思路。这一集，我们将会拆解网络协议栈中的<code>bind</code>系统调用。我们首先可以通过<code>man bind</code>命令来查看一下它的函数原型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span><br><span class="line"><span class="params">        <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p>首先它需要一个<code>sockfd</code>，即我们在<code>socket</code>系统调用中得到的结果。而第二和第三个参数则是传入了我们要绑定的地址。如果仔细阅读<code>man bind</code>中的信息，你可以找到<code>struct sockaddr</code>具体长什么样。下面展示了一个UNIX socket的地址格式，具体类型是<code>struct sockaddr_un</code>。当然我们现在常用的的socket格式还是网络协议相关的，例如TCP和UDP。那么我现在提出一个问题，操作系统是如何完成这么多不同种类的地址格式的兼容的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">my_addr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_SOCK_PATH <span class="string">&quot;/somepath&quot;</span></span></span><br><span class="line">my_addr.sun_family = AF_UNIX;</span><br><span class="line"><span class="built_in">strncpy</span>(my_addr.sun_path, MY_SOCK_PATH,</span><br><span class="line"><span class="keyword">sizeof</span>(my_addr.sun_path) - <span class="number">1</span>);</span><br><span class="line">bind(sfd, (<span class="keyword">struct</span> sockaddr *) &amp;my_addr,</span><br><span class="line">            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_un))</span><br></pre></td></tr></table></figure><p>我们可以使用正则表达式<code>struct sockaddr.* \&#123;</code>找到所有的地址结构体定义，记得使用工具的时候仅搜索头文件，这样可以大幅缩小查找范围。下面以<code>struct sockaddr</code>，<code>struct sockaddr_un</code>和<code>struct sockaddr_in</code>为例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用address定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="type">sa_family_t</span>sa_family;<span class="comment">/* address family, AF_xxx*/</span></span><br><span class="line"><span class="type">char</span>sa_data[<span class="number">14</span>];<span class="comment">/* 14 bytes of protocol address*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UNIX address定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line"><span class="type">__kernel_sa_family_t</span> sun_family; <span class="comment">/* AF_UNIX */</span></span><br><span class="line"><span class="type">char</span> sun_path[UNIX_PATH_MAX];<span class="comment">/* pathname */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IPv4协议族地址定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">__be32s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  <span class="type">__kernel_sa_family_t</span>sin_family;<span class="comment">/* Address family*/</span></span><br><span class="line">  __be16sin_port;<span class="comment">/* Port number*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span><span class="title">sin_addr</span>;</span><span class="comment">/* Internet address*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>__pad[__SOCK_SIZE__ - <span class="keyword">sizeof</span>(<span class="type">short</span> <span class="type">int</span>) -</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看见他们的共同点就是第一个元素都存储了自身的协议族。这样，无论这个结构体如何被强转类型，程序都可以获取到协议族信息，并以此来判断传入参数是否正确。此外，可以看见尽管<code>struct sockaddr</code>已经是一个长度明确的结构体，但是<code>bind</code>函数仍然要求传入<code>socklen_t addrlen</code>，可见这组API在设计之时也考虑到了后续的扩展，它允许协议开发者超过通用addr定义的14字节地址长度，就如UNIX address最长可以有108字节。</p><p>回到IPv4协议族，它包括了两个要素，IP地址和端口号。其中IP地址是一个<code>uint32</code>的整数，而端口号则是一个<code>uint16</code>的整数。剩余部分的pad，正如注释所述，用于补齐剩余字节，使得<code>struct sockaddr_in</code>和<code>struct sockaddr</code>大小一致。</p><h2 id="sys-bind：bind系统调用的入口"><a href="#sys-bind：bind系统调用的入口" class="headerlink" title="__sys_bind：bind系统调用的入口"></a>__sys_bind：bind系统调用的入口</h2><p>使用上一集讲到的方法，我们可以搜索正则表达式<code>&#39;SYSCALL_DEINE.\(bind&#39;</code>来找到bind的实现，如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __sys_bind(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr __user *umyaddr, <span class="type">int</span> addrlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line"><span class="type">int</span> err, fput_needed;</span><br><span class="line"></span><br><span class="line">sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line"><span class="keyword">if</span> (sock) &#123;</span><br><span class="line">err = move_addr_to_kernel(umyaddr, addrlen, &amp;address);</span><br><span class="line"><span class="keyword">if</span> (err &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">err = security_socket_bind(sock,</span><br><span class="line">   (<span class="keyword">struct</span> sockaddr *)&amp;address,</span><br><span class="line">   addrlen);</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line">err = sock-&gt;ops-&gt;bind(sock,</span><br><span class="line">      (<span class="keyword">struct</span> sockaddr *)</span><br><span class="line">      &amp;address, addrlen);</span><br><span class="line">&#125;</span><br><span class="line">fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个函数的逻辑还是很好理解的，首先通过<code>sockfd_lookup_light</code>函数，使用<code>fd</code>来查找到绑定的<code>sock</code>。其原理已经在上一集讲过了，简单来说，整个网络协议栈的上层IO都工作在一个VFS（虚拟文件系统）上，当我们试图在socket的VFS上创建一个inode的同时，我们就会创建出一个一一对应的socket。然后，我们再创建一个<code>struct file</code>，与这个inode绑定，并且为其分配一个fd（文件描述符）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> socket *<span class="title function_">sockfd_lookup_light</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> *err, <span class="type">int</span> *fput_needed)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget(fd);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">*err = -EBADF;</span><br><span class="line"><span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">sock = sock_from_file(f.file, err);</span><br><span class="line"><span class="keyword">if</span> (likely(sock)) &#123;</span><br><span class="line">*fput_needed = f.flags;</span><br><span class="line"><span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br><span class="line">fdput(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> socket *<span class="title function_">sock_from_file</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">int</span> *err)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (file-&gt;f_op == &amp;socket_file_ops)</span><br><span class="line"><span class="keyword">return</span> file-&gt;private_data;<span class="comment">/* set in sock_map_fd */</span></span><br><span class="line"></span><br><span class="line">*err = -ENOTSOCK;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试进入函数<code>sockfd_lookup_light</code>来验证我们的猜想。可以看见正如我们猜测的那样，首先可以通过<code>fdget</code>来获取到fd所对应的结构体，并且使用<code>sock_from_file</code>来从file中获取到我们的<code>struct socket</code>。倘若我们更进一步进入<code>sock_from_file</code>中，我们会发现其本质就是读取<code>f.file</code>中的<code>private_data</code>，即<code>struct socket</code>的指针，这就是上一集中我们看见<code>sock_alloc_file</code>函数放进去的内容。</p><h2 id="inet-bind：IPv4协议族的bind实现"><a href="#inet-bind：IPv4协议族的bind实现" class="headerlink" title="inet_bind：IPv4协议族的bind实现"></a>inet_bind：IPv4协议族的bind实现</h2><p>整个IPv4协议族的<code>bind</code>实现也是极为简单的，除去一些错误处理逻辑外，可以看见逻辑大致可以分为两个分支。</p><ol><li>如果具体的协议有自己的<code>bind</code>实现，那么使用协议的<code>bind</code>实现；</li><li>否则，使用默认的IPv4协议族<code>bind</code>实现。</li></ol><p>那么假设我们使用了TCP协议，那么会走到哪一条分支呢？在上一集中我们已经知道TCP协议的所有实现可以在<code>tcp_prot</code>这个全局变量中找到，它定义在<code>net/ipv4/tcp_ipv4.c</code>中，由于它太长了直接在文章中贴出来影响观感，这里就不再贴出了。观察这个变量，发现它并没有对<code>bind</code>字段进行赋值，也就是说我们将使用默认的inet_bind实现，<code>__inet_bind</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_bind</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> sockaddr *uaddr, <span class="type">int</span> addr_len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the socket has its own bind function then use it. (RAW) */</span></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_prot-&gt;bind) &#123;</span><br><span class="line"><span class="keyword">return</span> sk-&gt;sk_prot-&gt;bind(sk, uaddr, addr_len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* BPF prog is run before any checks are done so that if the prog</span></span><br><span class="line"><span class="comment"> * changes context in a wrong way it will be caught.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">err = BPF_CGROUP_RUN_PROG_INET4_BIND(sk, uaddr);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> __inet_bind(sk, uaddr, addr_len, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="inet-bind：TCP连接真正实现bind的地方"><a href="#inet-bind：TCP连接真正实现bind的地方" class="headerlink" title="__inet_bind：TCP连接真正实现bind的地方"></a>__inet_bind：TCP连接真正实现bind的地方</h2><p>这部分的代码大约有100行，并且没有明显的业务逻辑相关的函数调用，也就是说这个函数本身已经是相当底层了。那么，如果想要真的明白这个函数的含义，我们需要有一点思路并且仔细观察。</p><p>我的思路如下：</p><ol><li>因为<code>bind</code>函数本质上是告诉系统一个socket对应的地址，那么我们可以观察<code>uaddr</code>的去向。</li><li>尽管这个函数中有许多赋值和if判断干扰我们的思路，但是如果我们足够敏感的话，可以发现一组加锁和解锁的操作。在操作系统中，这意味着我们真正开始读写有意义的数据了。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __inet_bind(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sockaddr *uaddr, <span class="type">int</span> addr_len,</span><br><span class="line"><span class="type">bool</span> force_bind_address_no_port, <span class="type">bool</span> with_lock)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span> =</span> (<span class="keyword">struct</span> sockaddr_in *)uaddr;</span><br><span class="line"></span><br><span class="line">snum = ntohs(addr-&gt;sin_port);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些赋值和判断操作。。。。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (with_lock)</span><br><span class="line">lock_sock(sk);</span><br><span class="line"></span><br><span class="line">inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr = addr-&gt;sin_addr.s_addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (snum || <span class="comment">/* 一些其他的条件判断 */</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_prot-&gt;get_port(sk, snum)) &#123;</span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inet-&gt;inet_sport = htons(inet-&gt;inet_num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些重要的赋值和判断操作。。。。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">out_release_sock:</span><br><span class="line"><span class="keyword">if</span> (with_lock)</span><br><span class="line">release_sock(sk);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的思路，我们可以得到这样的一个思路框架，追踪<code>addr</code>的读写情况，我们大概率可以找到想要的内容。仔细阅读代码，可以发现使用<code>addr-&gt;sin_addr</code>的地方相当多，但是使用<code>addr-&gt;sin_port</code>的地方却只有两个，因此我决定从这里入手。通过谷歌可以知道<code>ntohs</code>函数的作用是将网络表达（network）的数据转换为本机表达（host），后缀s表示输出为<code>unsigned short</code>（uint16）类型。之所以需要这个函数是因为，本机的数据大小端是平台有关的，例如x86平台为大端，如<code>0x1234</code>在内存中表达，由低地址向高地址为<code>0x12 0x34</code>。而网络字节序规定传输内容为小端排列，即0x1234应当，由低向高地址表示为<code>0x34 0x12</code>。因此我们需要这样的一个函数来完成数据转换。额外的，arm平台规定用户可以在CPU上配置大小端，例如选择为小端系统，那么这个函数就是应当是一个空函数。类似的函数还有<code>htons</code>，<code>htonl</code>，<code>ntohl</code>，其中l后缀代表<code>unsigned long</code>，即uint32。</p><p>在获得了<code>snum</code>之后，我们可以很敏感的发现<code>sk-&gt;sk_prot-&gt;get_port(sk, snum)</code>其实又调用了一个TCP协议的内容，其功能应该是获取端口相关的逻辑。随后，可以发现似乎没有别地方使用端口号了。但是仔细思考，可以做出这样一个猜测，s代表source，而d代表destination。假设如此，那么<code>inet-&gt;inet_sport = htons(inet-&gt;inet_num)</code>很可能就是对端口号的赋值。</p><p>这样一来，我们引申出来两个问题：</p><ol><li><code>snum</code>是如何与<code>inet-&gt;inet_num</code>建立起关联的</li><li>为什么给<code>inet</code>赋值就可以完成bind的配置（它似乎只是一个局部变量，我们如何完成数据的持久化？）</li></ol><p>这两个问题在这个函数中似乎没有很好的回答，那么我们可以先去查看get_port函数。</p><h2 id="inet-csk-get-port的实现"><a href="#inet-csk-get-port的实现" class="headerlink" title="inet_csk_get_port的实现"></a>inet_csk_get_port的实现</h2><p>通过查阅<code>tcp_prot</code>结构体，可以发现<code>get_port</code>在TCP协议中的实现为<code>inet_csk_get_port</code>。暂且不讨论其中端口重用的逻辑的话，大体结构如下。整个函数不算短，但是逻辑很清晰。首先可以通过名字知道<code>struct inet_hashinfo *hinfo</code>是一个哈希表，其元数据定义在<code>sk-&gt;sk_prot-&gt;h.hashinfo</code>，即，在这里对应了<code>tcp_prot</code>的<code>h.hashinfo</code>字段。通过跳转，可以发现其就是一个定义在<code>net/ipv4/tcp_ipv4.c</code>的全局变量<code>struct inet_hashinfo tcp_hashinfo</code>。这也就一定程度上解释了操作系统是如何持久化bind的记录。</p><p>接下来的逻辑上，假设我们的<code>port</code>为0，那么我们会通过sk来尝试查找返回已经绑定的端口，如果没有则返回错误。这一段显然不是我们正在绑定端口时调用<code>get_port</code>需要的逻辑，而是绑定后查找端口所需的逻辑。</p><p>下一段逻辑，通过对<code>port</code>求哈希，加自旋锁（spinlock），然后查找对应和哈希链表上有没有我们想要的端口，如果没有，则创建之，并且返回，这是就是我们正常的主流程。如果有，那么我们则需要进行端口复用，这取决于协议的实现。如果读者愿意回头看看给<code>sk-&gt;sk_reuse</code>赋值的地方，可以发现在<code>inet_create</code>中有一行<code>if (INET_PROTOSW_REUSE &amp; answer_flags) sk-&gt;sk_reuse = SK_CAN_REUSE;</code>，而<code>answer_flags</code>来自于<code>inetsw_arrary</code>。其中TCP协议对应的flags为<code>INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK</code>，即TCP协议并不原生支持端口复用。这部分逻辑可以忽略。</p><p>此处进行一点补充，为了防止有人不知道哈希链表。其本质就是一个哈希表，表中每个元素为一个链表。这样做是因为哈希表有可能会撞哈希，即不同数据有极低概率拥有相同的哈希值，在这种情况下，我们将其用链表串起来。这样的数据结构拥有近似哈希表的速度，因为理想情况下哈希碰撞不会发生或极少发生。但是极端情况下，它会退化成一个链表，即进去的所有元素都发生了哈希碰撞。</p><p>接下来，有一个语句很可疑，<code>if (!inet_csk(sk)-&gt;icsk_bind_hash) inet_bind_hash(sk, tb, port);</code>。它与port，port生成的哈希表元素tb，以及sk都有关系，并且函数中提到了inet。那么它很可能和我们之前的疑问有关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_csk_get_port</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">unsigned</span> <span class="type">short</span> snum)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> reuse = sk-&gt;sk_reuse &amp;&amp; sk-&gt;sk_state != TCP_LISTEN;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_hashinfo</span> *<span class="title">hinfo</span> =</span> sk-&gt;sk_prot-&gt;h.hashinfo;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">1</span>, port = snum;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_hashbucket</span> *<span class="title">head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_bucket</span> *<span class="title">tb</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">kuid_t</span> uid = sock_i_uid(sk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!port) &#123;</span><br><span class="line">head = inet_csk_find_open_port(sk, &amp;tb, &amp;port);</span><br><span class="line"><span class="keyword">if</span> (!head)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="keyword">if</span> (!tb)</span><br><span class="line"><span class="keyword">goto</span> tb_not_found;</span><br><span class="line"><span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br><span class="line">head = &amp;hinfo-&gt;bhash[inet_bhashfn(net, port,</span><br><span class="line">  hinfo-&gt;bhash_size)];</span><br><span class="line">spin_lock_bh(&amp;head-&gt;lock);</span><br><span class="line">inet_bind_bucket_for_each(tb, &amp;head-&gt;chain)</span><br><span class="line"><span class="keyword">if</span> (net_eq(ib_net(tb), net) &amp;&amp; tb-&gt;port == port)</span><br><span class="line"><span class="keyword">goto</span> tb_found;</span><br><span class="line">tb_not_found:</span><br><span class="line">tb = inet_bind_bucket_create(hinfo-&gt;bind_bucket_cachep,</span><br><span class="line">     net, head, port);</span><br><span class="line"><span class="keyword">if</span> (!tb)</span><br><span class="line"><span class="keyword">goto</span> fail_unlock;</span><br><span class="line">tb_found:</span><br><span class="line"><span class="comment">// 检查是否可以端口复用</span></span><br><span class="line"><span class="keyword">if</span> (!hlist_empty(&amp;tb-&gt;owners)) &#123;</span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_reuse == SK_FORCE_REUSE)</span><br><span class="line"><span class="keyword">goto</span> success;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((tb-&gt;fastreuse &gt; <span class="number">0</span> &amp;&amp; reuse) ||</span><br><span class="line">    sk_reuseport_match(tb, sk))</span><br><span class="line"><span class="keyword">goto</span> success;</span><br><span class="line"><span class="keyword">if</span> (inet_csk_bind_conflict(sk, tb, <span class="literal">true</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="keyword">goto</span> fail_unlock;</span><br><span class="line">&#125;</span><br><span class="line">success:</span><br><span class="line"><span class="comment">// 省略端口复用相关的逻辑...</span></span><br><span class="line"><span class="keyword">if</span> (!inet_csk(sk)-&gt;icsk_bind_hash)</span><br><span class="line">inet_bind_hash(sk, tb, port);</span><br><span class="line">WARN_ON(inet_csk(sk)-&gt;icsk_bind_hash != tb);</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_unlock:</span><br><span class="line">spin_unlock_bh(&amp;head-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入这个函数，我们可以看见<code>snum</code>，即端口号确实赋值给了<code>inet-&gt;inet_num</code>。并且记录了它所对应的哈希表位置。此时，我们应当有意识地意识到<code>inet_sk</code>和<code>inet_csk</code>这两个函数并不简单。进入这两个函数可以发现他们是一个简单的强转，即类似于<code>return (struct inet_sock *)sk</code>这样的形式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inet_bind_hash</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> inet_bind_bucket *tb,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> snum)</span></span><br><span class="line">&#123;</span><br><span class="line">inet_sk(sk)-&gt;inet_num = snum;</span><br><span class="line">sk_add_bind_node(sk, &amp;tb-&gt;owners);</span><br><span class="line">inet_csk(sk)-&gt;icsk_bind_hash = tb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步地，我们查看<code>struct sock</code>，<code>struct inet_sock</code>和<code>struct inet_connection_sock</code>和定义，可以发现这样的包含关系。并且额外的，作为剧透，我可以告诉读者还有一个<code>tcp_sock</code>套在<code>inet_connection_sock</code>外层。也就是说，我们一直使用的<code>struct sock</code>其实是一个“基类”，而它真正的类型其实是<code>struct tcp_sock</code>（因为我们在&#96;&#96;socket<code>系统调用，</code>sock_create<code>函数中调用</code>pf-&gt;create<code>，调用到了</code>inet_create<code>，其中使用了</code>sk_alloc<code>创建</code>struct sock<code>，并且这个函数知道我们使用的协议。整个逻辑链很清晰，感兴趣的读者可以自行阅读，最终可以看见底层是函数根据</code>tcp_prot<code>中的</code>obj_size<code>来进行</code>kmalloc<code>，而</code>obj_size &#x3D; sizeof(struct tcp_sock)&#96;。使用这样的技巧，C语言可以实现一些面向对象中继承的特性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span><span class="title">sk</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span>  <span class="title">icsk_inet</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span>  <span class="title">inet_conn</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小结：让我们回到-inet-bind"><a href="#小结：让我们回到-inet-bind" class="headerlink" title="小结：让我们回到__inet_bind"></a>小结：让我们回到__inet_bind</h2><p>至此，我们应该已经可以回答之前提出的两个问题。<code>bind</code>函数本质上只是将地址和端口存入全局变量中。地址会被放入内存堆上的<code>struct sock *sk</code>中，而端口除了会被放在sk中，还会放在一个全局的哈希表中，用于快速查找是否有重复的端口占用。这些数据通过<code>struct sock *sk</code>串联起来。而其也不是一个简单的<code>struct sock</code>，本质上是一个<code>struct tcp_sock</code>对象，我们针对不同函数，有限度地将其强转为不同层次所需要的结构。总的来说，<code>bind</code>的实现是相当简单的，仅仅涉及到一些全局变量的读写操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Bind系统调用的定义&quot;&gt;&lt;a href=&quot;#Bind系统调用的定义&quot; class=&quot;headerlink&quot; title=&quot;Bind系统调用的定义&quot;&gt;&lt;/a&gt;Bind系统调用的定义&lt;/h2&gt;&lt;p&gt;在上一集，我们讨论了&lt;code&gt;socket&lt;/code&gt;系统调用的</summary>
      
    
    
    
    
  </entry>
  
</feed>
